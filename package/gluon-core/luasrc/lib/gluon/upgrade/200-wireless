#!/usr/bin/lua

local util = require 'gluon.util'
local wireless = require 'gluon.wireless'
local site = require 'gluon.site'
local iwinfo = require 'iwinfo'

local uci = require('simple-uci').cursor()

-- recreate radios
os.execute('rm /etc/config/wireless && wifi config')

-- delete default wireless config
uci:delete_all('wireless', 'wifi-iface')
uci:save('wireless')


local radio_band_count = {band_2g=0, band_5g=0}

local function count_band(band)
	radio_band_count[band] = radio_band_count[band] + 1
end

-- First count all radios with a fixed frequency band.
-- This is needed to distribute devices which have radios
-- capable of operating in the 2.4 GHz and 5 GHz band need
-- to be distributed evenly.
wireless.foreach_radio(uci, function(radio)
	local hwmodes = iwinfo.nl80211.hwmodelist(wireless.find_phy(radio))
	if hwmodes.g and not (hwmodes.a or hwmodes.ac) then
		-- 2.4 GHz
		count_band("band_2g")
	elseif (hwmodes.a or hwmodes.ac) and not hwmodes.g then
		-- 5 GHz
		count_band("band_5g")
	end
end)

-- Use the number of all fixed 2.4G GHz and 5 GHz radios to
-- distribute dualband radios in this step.
wireless.foreach_radio(uci, function(radio)
	local radio_name = radio['.name']
	local hwmodes = iwinfo.nl80211.hwmodelist(wireless.find_phy(radio))
	if (hwmodes.a or hwmodes.ac) and hwmodes.g then
		-- Dualband radio
		if radio_band_count["band_2g"] <= radio_band_count["band_5g"] then
			-- Assign radio to 2.4GHz band
			count_band("band_2g")
			uci:set('wireless', radio_name, 'band', '2g')
		else
			-- Assign radio to 5GHz band
			count_band("band_5g")
			uci:set('wireless', radio_name, 'band', '5g')
		end
	end
end)

local function get_wradio(radio)
	local wradio_name
	uci:foreach('gluon', 'wireless_radio', function(wradio)
		if wradio.path == radio.path then
			wradio_name = wradio['.name']
		end
	end)
	return wradio_name
end

local function get_txpower(radio)
	local wradio_name = get_wradio(radio)
	return uci:get('gluon', wradio_name, 'txpower')
end

local function get_htmode(radio)
	local wradio_name = get_wradio(radio)
	local htmode = uci:get('gluon', wradio_name, 'htmode')
	if htmode ~= nil then
		return htmode
	end

	local channel_width = 20

	if radio.band == '2g' then
		channel_width = site.wifi24.channel_width(20)
	elseif radio.band == '5g' then
		channel_width = site.wifi5.channel_width(20)
	end

	local phy = wireless.find_phy(radio)
	if iwinfo.nl80211.hwmodelist(phy).ax then
		htmode = 'HE' .. channel_width
	elseif iwinfo.nl80211.hwmodelist(phy).ac then
		htmode = 'VHT' .. channel_width
	else
		htmode = 'HT' .. channel_width
	end

	local last_mode

	for mode, available in pairs(iwinfo.nl80211.htmodelist(phy)) do
		if available and mode == htmode then
			return htmode
		end

		last_mode = mode
	end

	-- if preferred htmode is not available
	-- select the last one we got
	return last_mode
end

local function configure_mesh(radio, index, mesh_config)
	local radio_name = radio['.name']
	local name = 'mesh_' .. radio_name

	local macfilter = uci:get('wireless', name, 'macfilter')
	local maclist = uci:get('wireless', name, 'maclist')
	local suffix = radio_name:match('^radio(%d+)$')

	if not mesh_config or not suffix then
		return
	end

	local macaddr = wireless.get_wlan_mac('mesh', index, radio)
	if not macaddr then
		return
	end

	uci:section('network', 'interface', name, {
		proto = 'gluon_mesh',
		hop_penalty = wireless.radio_option(uci, radio, 'batadv_hop_penalty')
	})

	uci:section('wireless', 'wifi-iface', name, {
		device = radio_name,
		network = name,
		mode = 'mesh',
		mesh_id = mesh_config.id,
		mesh_fwding = false,
		mesh_nolearn = true,
		macaddr = macaddr,
		basic_rate = { mesh_config.mcast_rate },
		mcast_rate = mesh_config.mcast_rate,
		ifname = 'mesh' .. suffix,
		macfilter = macfilter,
		maclist = maclist,
	})
end

local function set_channels(radio, config)
	local radio_name = radio['.name']
	local wradio_name = get_wradio(radio)
	local channel = uci:get('gluon', wradio_name, 'channel')
	if not channel then
		channel = wireless.get_channel(radio, config, uci)
	end
	uci:set('wireless', radio_name, 'channel', channel)

	local chanlist
	if radio.band == '5g' and wireless.is_outdoor(uci) then
		chanlist = config.outdoor_chanlist()
	end
	uci:set('wireless', radio_name, 'channels', chanlist)
end

wireless.foreach_radio(uci, function(radio, index, config)
	local radio_name = radio['.name']

	if not config() then
		uci:set('wireless', radio_name, 'disabled', true)
		return
	end

	local suffix = radio_name:match('^radio(%d+)$')
	if not suffix then
		return
	end

	local txpower = get_txpower(radio)
	if txpower ~= nil then
		uci:set('wireless', radio_name, 'txpower', txpower)
	end

	local htmode = get_htmode(radio)
	local beacon_interval = config.beacon_interval()

	uci:delete('wireless', radio_name, 'disabled')

	set_channels(radio, config)

	uci:set('wireless', radio_name, 'htmode', htmode)
	uci:set('wireless', radio_name, 'country', site.regdom())

	uci:delete('wireless', radio_name, 'supported_rates')
	uci:delete('wireless', radio_name, 'basic_rate')

	local band = radio.band
	-- now we assign radios to roles
	local roles = wireless.radio_roles(uci, radio)
	local enable_mesh = wireless.supports_channel(radio, config.channel()) and util.contains(roles, 'mesh')

	if band == '2g' then
		uci:set('wireless', radio_name, 'legacy_rates', false)
		if enable_mesh then
			configure_mesh(radio, index, config.mesh())
		end
	elseif band == '5g' then
		if wireless.is_outdoor(uci) then
			-- enforce outdoor channels by filtering the regdom for outdoor channels
			uci:set('wireless', radio_name, 'country3', '0x4f')
		else
			uci:delete('wireless', radio_name, 'country3')

			if enable_mesh then
				configure_mesh(radio, index, config.mesh())
			end
		end
	end

	uci:set('wireless', radio_name, 'beacon_int', beacon_interval)
end)


if uci:get('system', 'rssid_wlan0') then
	uci:set('system', 'rssid_wlan0', 'dev', 'mesh0')
	uci:save('system')
end

if uci:get('system', 'rssid_wlan1') then
	uci:set('system', 'rssid_wlan1', 'dev', 'mesh1')
	uci:save('system')
end

uci:save('wireless')
uci:save('network')
