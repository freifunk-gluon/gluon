From: David Bauer <mail@david-bauer.net>
Date: Fri, 6 Feb 2026 08:55:24 +0100
Subject: wifi: mac80211: ps airtime buffering

diff --git a/package/kernel/mac80211/patches/subsys/800-wifi-mac80211-add-flag-for-driver-buffering-of-PS.patch b/package/kernel/mac80211/patches/subsys/800-wifi-mac80211-add-flag-for-driver-buffering-of-PS.patch
new file mode 100644
index 0000000000000000000000000000000000000000..4f38afb2807dfab35149b44065f1f663a8f2cbe3
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/800-wifi-mac80211-add-flag-for-driver-buffering-of-PS.patch
@@ -0,0 +1,48 @@
+From 273231019417e3d98804cdacfd4f539e1208f99b Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Wed, 4 Feb 2026 21:57:52 +0100
+Subject: [PATCH] wifi: mac80211: add flag for driver-buffering of PS
+
+---
+ include/net/mac80211.h | 5 +++++
+ net/mac80211/debugfs.c | 1 +
+ 2 files changed, 6 insertions(+)
+
+diff --git a/include/net/mac80211.h b/include/net/mac80211.h
+index 36ae7fe9ddf35..1030ba6c2fab9 100644
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -2871,6 +2871,10 @@ struct ieee80211_txq {
+  *	HW flag so drivers can opt in according to their own control, e.g. in
+  *	testing.
+  *
++ * @IEEE80211_HW_STORES_PS_FRAMES: Hardware/driver stores frames for
++ *	power-saving stations instead of returning them to mac80211 for
++ *	buffering.
++ *
+  * @NUM_IEEE80211_HW_FLAGS: number of hardware flags, used for sizing arrays
+  */
+ enum ieee80211_hw_flags {
+@@ -2931,6 +2935,7 @@ enum ieee80211_hw_flags {
+ 	IEEE80211_HW_DISALLOW_PUNCTURING,
+ 	IEEE80211_HW_HANDLES_QUIET_CSA,
+ 	IEEE80211_HW_STRICT,
++	IEEE80211_HW_STORES_PS_FRAMES,
+ 
+ 	/* keep last, obviously */
+ 	NUM_IEEE80211_HW_FLAGS
+diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
+index d02f07368c511..eb27eb2a8191f 100644
+--- a/net/mac80211/debugfs.c
++++ b/net/mac80211/debugfs.c
+@@ -490,6 +490,7 @@ static const char *hw_flag_names[] = {
+ 	FLAG(DISALLOW_PUNCTURING),
+ 	FLAG(HANDLES_QUIET_CSA),
+ 	FLAG(STRICT),
++	FLAG(STORES_PS_FRAMES),
+ #undef FLAG
+ };
+ 
+-- 
+2.51.0
+
diff --git a/package/kernel/mac80211/patches/subsys/801-wifi-mac80211-introduce-framework-for-exempt-PS-stat.patch b/package/kernel/mac80211/patches/subsys/801-wifi-mac80211-introduce-framework-for-exempt-PS-stat.patch
new file mode 100644
index 0000000000000000000000000000000000000000..5bfd8e3655dff8658a8efab852a2c2ce06eb64c8
--- /dev/null
+++ b/package/kernel/mac80211/patches/subsys/801-wifi-mac80211-introduce-framework-for-exempt-PS-stat.patch
@@ -0,0 +1,143 @@
+From 19693990a8048d4f4e94229610083d2427635f9b Mon Sep 17 00:00:00 2001
+From: David Bauer <mail@david-bauer.net>
+Date: Fri, 30 Jan 2026 17:02:04 +0100
+Subject: [PATCH] wifi: mac80211: introduce framework for exempt PS stations
+ from airtime accounting
+
+---
+ net/mac80211/ieee80211_i.h |  3 +++
+ net/mac80211/main.c        |  2 ++
+ net/mac80211/rx.c          |  7 +++++-
+ net/mac80211/sta_info.c    | 47 ++++++++++++++++++++++++++++++++++++++
+ net/mac80211/sta_info.h    |  1 +
+ 5 files changed, 59 insertions(+), 1 deletion(-)
+
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -1385,6 +1385,9 @@ struct ieee80211_local {
+ 
+ 	const struct ieee80211_ops *ops;
+ 
++	atomic_t aql_total_pending_airtime_ps;
++	atomic_t aql_ac_pending_airtime_ps[IEEE80211_NUM_ACS];
++
+ 	/*
+ 	 * private workqueue to mac80211. mac80211 makes this accessible
+ 	 * via ieee80211_queue_work()
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -962,11 +962,13 @@ struct ieee80211_hw *ieee80211_alloc_hw_
+ 		local->aql_txq_limit_high[i] =
+ 			IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H;
+ 		atomic_set(&local->aql_ac_pending_airtime[i], 0);
++		atomic_set(&local->aql_ac_pending_airtime_ps[i], 0);
+ 	}
+ 
+ 	local->airtime_flags = AIRTIME_USE_TX | AIRTIME_USE_RX;
+ 	local->aql_threshold = IEEE80211_AQL_THRESHOLD;
+ 	atomic_set(&local->aql_total_pending_airtime, 0);
++	atomic_set(&local->aql_total_pending_airtime_ps, 0);
+ 
+ 	spin_lock_init(&local->handle_wake_tx_queue_lock);
+ 
+--- a/net/mac80211/rx.c
++++ b/net/mac80211/rx.c
+@@ -1586,6 +1586,8 @@ static void sta_ps_start(struct sta_info
+ 	ps_dbg(sdata, "STA %pM aid %d enters power save mode\n",
+ 	       sta->sta.addr, sta->sta.aid);
+ 
++	ieee80211_sta_recalc_pending_airtime_ps(sta);
++
+ 	ieee80211_clear_fast_xmit(sta);
+ 
+ 	for (tid = 0; tid < IEEE80211_NUM_TIDS; tid++) {
+@@ -1619,12 +1621,15 @@ static void sta_ps_end(struct sta_info *
+ 		clear_sta_flag(sta, WLAN_STA_PS_STA);
+ 		ps_dbg(sta->sdata, "STA %pM aid %d driver-ps-blocked\n",
+ 		       sta->sta.addr, sta->sta.aid);
+-		return;
++		goto out;
+ 	}
+ 
+ 	set_sta_flag(sta, WLAN_STA_PS_DELIVER);
+ 	clear_sta_flag(sta, WLAN_STA_PS_STA);
+ 	ieee80211_sta_ps_deliver_wakeup(sta);
++
++out:
++	ieee80211_sta_recalc_pending_airtime_ps(sta);
+ }
+ 
+ int ieee80211_sta_ps_transition(struct ieee80211_sta *pubsta, bool start)
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -153,6 +153,8 @@ static void __cleanup_single_sta(struct
+ 		clear_sta_flag(sta, WLAN_STA_PS_DELIVER);
+ 
+ 		atomic_dec(&ps->num_sta_ps);
++
++		ieee80211_sta_recalc_pending_airtime_ps(sta);
+ 	}
+ 
+ 	ieee80211_purge_sta_txqs(sta);
+@@ -2358,6 +2360,51 @@ void ieee80211_sta_recalc_aggregates(str
+ }
+ EXPORT_SYMBOL(ieee80211_sta_recalc_aggregates);
+ 
++static int ieee80211_sta_has_tx_pending(struct ieee80211_local *local, struct sta_info *sta)
++{
++	int ac;
++
++	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
++		if (atomic_read(&sta->airtime[ac].aql_tx_pending))
++			return 1;
++	}
++
++	return 0;
++}
++
++void ieee80211_sta_recalc_pending_airtime_ps(struct sta_info *sta)
++{
++	struct ieee80211_local *local = sta->local;
++	int ac_ps_airtime[IEEE80211_NUM_ACS] = {0};
++	int total_ps_airtime = 0;
++	int tx_pending = 0;
++	int ac;
++
++	if (!ieee80211_hw_check(&local->hw, STORES_PS_FRAMES))
++		return;
++
++	/* Only need to recalc if STA has TX pending */
++	if (!ieee80211_sta_has_tx_pending(local, sta))
++		return;
++
++	rcu_read_lock();
++	list_for_each_entry_rcu(sta, &local->sta_list, list) {
++		if (!test_sta_flag(sta, WLAN_STA_PS_STA))
++			continue;
++
++		for (ac = 0; ac < IEEE80211_NUM_ACS; ac++) {
++			tx_pending = atomic_read(&sta->airtime[ac].aql_tx_pending);
++			ac_ps_airtime[ac] += tx_pending;
++			total_ps_airtime += tx_pending;
++		}
++	}
++	rcu_read_unlock();
++
++	atomic_set(&local->aql_total_pending_airtime_ps, total_ps_airtime);
++	for (ac = 0; ac < IEEE80211_NUM_ACS; ac++)
++		atomic_set(&local->aql_ac_pending_airtime_ps[ac], ac_ps_airtime[ac]);
++}
++
+ void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
+ 					  struct sta_info *sta, u8 ac,
+ 					  u16 tx_airtime, bool tx_completed,
+--- a/net/mac80211/sta_info.h
++++ b/net/mac80211/sta_info.h
+@@ -145,6 +145,7 @@ struct airtime_info {
+ 	u32 aql_limit_high;
+ };
+ 
++void ieee80211_sta_recalc_pending_airtime_ps(struct sta_info *sta);
+ void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
+ 					  struct sta_info *sta, u8 ac,
+ 					  u16 tx_airtime, bool tx_completed,
