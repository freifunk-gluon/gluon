From: Matthias Schiffer <mschiffer@universe-factory.net>
Date: Sat, 7 May 2016 00:07:51 +0200
Subject: kernel: backport spi-nor driver from 4.4.9

diff --git a/target/linux/ar71xx/patches-3.18/407-mtd-m25p80-allow-to-pass-probe-types-via-platform-data.patch b/target/linux/ar71xx/patches-3.18/407-mtd-m25p80-allow-to-pass-probe-types-via-platform-data.patch
index 568f516..6a91320 100644
--- a/target/linux/ar71xx/patches-3.18/407-mtd-m25p80-allow-to-pass-probe-types-via-platform-data.patch
+++ b/target/linux/ar71xx/patches-3.18/407-mtd-m25p80-allow-to-pass-probe-types-via-platform-data.patch
@@ -1,11 +1,11 @@
 --- a/drivers/mtd/devices/m25p80.c
 +++ b/drivers/mtd/devices/m25p80.c
-@@ -246,7 +246,9 @@ static int m25p_probe(struct spi_device
+@@ -229,7 +229,9 @@ static int m25p_probe(struct spi_device
  
  	ppdata.of_node = spi->dev.of_node;
  
--	return mtd_device_parse_register(&flash->mtd, NULL, &ppdata,
-+	return mtd_device_parse_register(&flash->mtd,
+-	return mtd_device_parse_register(&nor->mtd, NULL, &ppdata,
++	return mtd_device_parse_register(&nor->mtd,
 +			data ? data->part_probes : NULL,
 +			&ppdata,
  			data ? data->parts : NULL,
diff --git a/target/linux/ar71xx/patches-3.18/412-mtd-m25p80-zero-partition-parser-data.patch b/target/linux/ar71xx/patches-3.18/412-mtd-m25p80-zero-partition-parser-data.patch
index d51694d..175acf6 100644
--- a/target/linux/ar71xx/patches-3.18/412-mtd-m25p80-zero-partition-parser-data.patch
+++ b/target/linux/ar71xx/patches-3.18/412-mtd-m25p80-zero-partition-parser-data.patch
@@ -1,10 +1,10 @@
 --- a/drivers/mtd/devices/m25p80.c
 +++ b/drivers/mtd/devices/m25p80.c
-@@ -244,6 +244,7 @@ static int m25p_probe(struct spi_device
+@@ -227,6 +227,7 @@ static int m25p_probe(struct spi_device
  	if (ret)
  		return ret;
  
 +	memset(&ppdata, '\0', sizeof(ppdata));
  	ppdata.of_node = spi->dev.of_node;
  
- 	return mtd_device_parse_register(&flash->mtd,
+ 	return mtd_device_parse_register(&nor->mtd,
diff --git a/target/linux/ar71xx/patches-3.18/462-mtd-m25p80-set-spi-transfer-type.patch b/target/linux/ar71xx/patches-3.18/462-mtd-m25p80-set-spi-transfer-type.patch
index 3320e5b..11bf9ff 100644
--- a/target/linux/ar71xx/patches-3.18/462-mtd-m25p80-set-spi-transfer-type.patch
+++ b/target/linux/ar71xx/patches-3.18/462-mtd-m25p80-set-spi-transfer-type.patch
@@ -1,6 +1,6 @@
 --- a/drivers/mtd/devices/m25p80.c
 +++ b/drivers/mtd/devices/m25p80.c
-@@ -142,10 +142,12 @@ static int m25p80_read(struct spi_nor *n
+@@ -137,10 +137,12 @@ static int m25p80_read(struct spi_nor *n
  	flash->command[0] = nor->read_opcode;
  	m25p_addr2cmd(nor, from, flash->command);
  
diff --git a/target/linux/ar71xx/patches-3.18/464-spi-ath79-fix-fast-flash-read.patch b/target/linux/ar71xx/patches-3.18/464-spi-ath79-fix-fast-flash-read.patch
index e48665d..758d231 100644
--- a/target/linux/ar71xx/patches-3.18/464-spi-ath79-fix-fast-flash-read.patch
+++ b/target/linux/ar71xx/patches-3.18/464-spi-ath79-fix-fast-flash-read.patch
@@ -1,6 +1,6 @@
 --- a/drivers/mtd/devices/m25p80.c
 +++ b/drivers/mtd/devices/m25p80.c
-@@ -142,6 +142,9 @@ static int m25p80_read(struct spi_nor *n
+@@ -137,6 +137,9 @@ static int m25p80_read(struct spi_nor *n
  	flash->command[0] = nor->read_opcode;
  	m25p_addr2cmd(nor, from, flash->command);
  
@@ -25,7 +25,7 @@
  	while (len--) {
 --- a/include/linux/spi/spi.h
 +++ b/include/linux/spi/spi.h
-@@ -637,6 +637,7 @@ struct spi_transfer {
+@@ -633,6 +633,7 @@ struct spi_transfer {
  	u16		delay_usecs;
  	u32		speed_hz;
  	enum spi_transfer_type type;
diff --git a/target/linux/brcm63xx/patches-3.18/202-MTD-DEVICES-m25p80-use-parsers-if-provided-in-flash-.patch b/target/linux/brcm63xx/patches-3.18/202-MTD-DEVICES-m25p80-use-parsers-if-provided-in-flash-.patch
index b949694..be62e67 100644
--- a/target/linux/brcm63xx/patches-3.18/202-MTD-DEVICES-m25p80-use-parsers-if-provided-in-flash-.patch
+++ b/target/linux/brcm63xx/patches-3.18/202-MTD-DEVICES-m25p80-use-parsers-if-provided-in-flash-.patch
@@ -11,12 +11,12 @@ Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
 
 --- a/drivers/mtd/devices/m25p80.c
 +++ b/drivers/mtd/devices/m25p80.c
-@@ -246,7 +246,8 @@ static int m25p_probe(struct spi_device
+@@ -229,7 +229,8 @@ static int m25p_probe(struct spi_device
  
  	ppdata.of_node = spi->dev.of_node;
  
--	return mtd_device_parse_register(&flash->mtd, NULL, &ppdata,
-+	return mtd_device_parse_register(&flash->mtd,
+-	return mtd_device_parse_register(&nor->mtd, NULL, &ppdata,
++	return mtd_device_parse_register(&nor->mtd,
 +			data ? data->part_probe_types : NULL, &ppdata,
  			data ? data->parts : NULL,
  			data ? data->nr_parts : 0);
diff --git a/target/linux/brcm63xx/patches-3.18/203-MTD-DEVICES-m25p80-add-support-for-limiting-reads.patch b/target/linux/brcm63xx/patches-3.18/203-MTD-DEVICES-m25p80-add-support-for-limiting-reads.patch
index 740fb2d..3877442 100644
--- a/target/linux/brcm63xx/patches-3.18/203-MTD-DEVICES-m25p80-add-support-for-limiting-reads.patch
+++ b/target/linux/brcm63xx/patches-3.18/203-MTD-DEVICES-m25p80-add-support-for-limiting-reads.patch
@@ -11,15 +11,15 @@ Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
 
 --- a/drivers/mtd/devices/m25p80.c
 +++ b/drivers/mtd/devices/m25p80.c
-@@ -32,6 +32,7 @@ struct m25p {
+@@ -31,6 +31,7 @@
+ struct m25p {
  	struct spi_device	*spi;
  	struct spi_nor		spi_nor;
- 	struct mtd_info		mtd;
 +	int			max_transfer_len;
  	u8			command[MAX_CMD_SIZE];
  };
  
-@@ -121,7 +122,7 @@ static inline unsigned int m25p80_rx_nbi
+@@ -119,7 +120,7 @@ static inline unsigned int m25p80_rx_nbi
   * Read an address range from the nor chip.  The address range
   * may be any size provided it is within the physical boundaries.
   */
@@ -28,7 +28,7 @@ Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
  			size_t *retlen, u_char *buf)
  {
  	struct m25p *flash = nor->priv;
-@@ -157,6 +158,29 @@ static int m25p80_read(struct spi_nor *n
+@@ -152,6 +153,29 @@ static int m25p80_read(struct spi_nor *n
  	return 0;
  }
  
@@ -58,7 +58,7 @@ Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
  static int m25p80_erase(struct spi_nor *nor, loff_t offset)
  {
  	struct m25p *flash = nor->priv;
-@@ -240,6 +264,9 @@ static int m25p_probe(struct spi_device
+@@ -223,6 +247,9 @@ static int m25p_probe(struct spi_device
  	else
  		flash_name = spi->modalias;
  
diff --git a/target/linux/brcm63xx/patches-3.18/414-MTD-m25p80-allow-passing-pp_data.patch b/target/linux/brcm63xx/patches-3.18/414-MTD-m25p80-allow-passing-pp_data.patch
index b7bf57f..e421e9a 100644
--- a/target/linux/brcm63xx/patches-3.18/414-MTD-m25p80-allow-passing-pp_data.patch
+++ b/target/linux/brcm63xx/patches-3.18/414-MTD-m25p80-allow-passing-pp_data.patch
@@ -10,7 +10,7 @@ Subject: [PATCH 64/79] MTD: m25p80: allow passing pp_data
 
 --- a/drivers/mtd/devices/m25p80.c
 +++ b/drivers/mtd/devices/m25p80.c
-@@ -267,6 +267,9 @@ static int m25p_probe(struct spi_device
+@@ -250,6 +250,9 @@ static int m25p_probe(struct spi_device
  	if (data)
  		flash->max_transfer_len = data->max_transfer_len;
  
diff --git a/target/linux/generic/patches-3.18/043-mtd_GD25Q128B_support_backport_from_3.19.patch b/target/linux/generic/patches-3.18/043-mtd_GD25Q128B_support_backport_from_3.19.patch
deleted file mode 100644
index 4d0403b..0000000
--- a/target/linux/generic/patches-3.18/043-mtd_GD25Q128B_support_backport_from_3.19.patch
+++ /dev/null
@@ -1,10 +0,0 @@
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -510,6 +510,7 @@ static const struct spi_device_id spi_no
- 	/* GigaDevice */
- 	{ "gd25q32", INFO(0xc84016, 0, 64 * 1024,  64, SECT_4K) },
- 	{ "gd25q64", INFO(0xc84017, 0, 64 * 1024, 128, SECT_4K) },
-+	{ "gd25q128", INFO(0xc84018, 0, 64 * 1024, 256, SECT_4K) },
- 
- 	/* Intel/Numonyx -- xxxs33b */
- 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
diff --git a/target/linux/generic/patches-3.18/093-m25p80_spi-nor_update_to_4.4.9.patch b/target/linux/generic/patches-3.18/093-m25p80_spi-nor_update_to_4.4.9.patch
new file mode 100644
index 0000000..5f74d3a
--- /dev/null
+++ b/target/linux/generic/patches-3.18/093-m25p80_spi-nor_update_to_4.4.9.patch
@@ -0,0 +1,1579 @@
+--- a/drivers/mtd/devices/m25p80.c
++++ b/drivers/mtd/devices/m25p80.c
+@@ -31,7 +31,6 @@
+ struct m25p {
+ 	struct spi_device	*spi;
+ 	struct spi_nor		spi_nor;
+-	struct mtd_info		mtd;
+ 	u8			command[MAX_CMD_SIZE];
+ };
+ 
+@@ -62,8 +61,7 @@ static int m25p_cmdsz(struct spi_nor *no
+ 	return 1 + nor->addr_width;
+ }
+ 
+-static int m25p80_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len,
+-			int wr_en)
++static int m25p80_write_reg(struct spi_nor *nor, u8 opcode, u8 *buf, int len)
+ {
+ 	struct m25p *flash = nor->priv;
+ 	struct spi_device *spi = flash->spi;
+@@ -128,13 +126,10 @@ static int m25p80_read(struct spi_nor *n
+ 	struct spi_device *spi = flash->spi;
+ 	struct spi_transfer t[2];
+ 	struct spi_message m;
+-	int dummy = nor->read_dummy;
+-	int ret;
++	unsigned int dummy = nor->read_dummy;
+ 
+-	/* Wait till previous write/erase is done. */
+-	ret = nor->wait_till_ready(nor);
+-	if (ret)
+-		return ret;
++	/* convert the dummy cycles to the number of bytes */
++	dummy /= 8;
+ 
+ 	spi_message_init(&m);
+ 	memset(t, 0, (sizeof t));
+@@ -160,20 +155,9 @@ static int m25p80_read(struct spi_nor *n
+ static int m25p80_erase(struct spi_nor *nor, loff_t offset)
+ {
+ 	struct m25p *flash = nor->priv;
+-	int ret;
+ 
+ 	dev_dbg(nor->dev, "%dKiB at 0x%08x\n",
+-		flash->mtd.erasesize / 1024, (u32)offset);
+-
+-	/* Wait until finished previous write command. */
+-	ret = nor->wait_till_ready(nor);
+-	if (ret)
+-		return ret;
+-
+-	/* Send write enable, then erase commands. */
+-	ret = nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0, 0);
+-	if (ret)
+-		return ret;
++		flash->spi_nor.mtd.erasesize / 1024, (u32)offset);
+ 
+ 	/* Set up command buffer. */
+ 	flash->command[0] = nor->erase_opcode;
+@@ -215,11 +199,10 @@ static int m25p_probe(struct spi_device
+ 	nor->read_reg = m25p80_read_reg;
+ 
+ 	nor->dev = &spi->dev;
+-	nor->mtd = &flash->mtd;
++	nor->flash_node = spi->dev.of_node;
+ 	nor->priv = flash;
+ 
+ 	spi_set_drvdata(spi, flash);
+-	flash->mtd.priv = nor;
+ 	flash->spi = spi;
+ 
+ 	if (spi->mode & SPI_RX_QUAD)
+@@ -228,7 +211,7 @@ static int m25p_probe(struct spi_device
+ 		mode = SPI_NOR_DUAL;
+ 
+ 	if (data && data->name)
+-		flash->mtd.name = data->name;
++		nor->mtd.name = data->name;
+ 
+ 	/* For some (historical?) reason many platforms provide two different
+ 	 * names in flash_platform_data: "name" and "type". Quite often name is
+@@ -246,7 +229,7 @@ static int m25p_probe(struct spi_device
+ 
+ 	ppdata.of_node = spi->dev.of_node;
+ 
+-	return mtd_device_parse_register(&flash->mtd, NULL, &ppdata,
++	return mtd_device_parse_register(&nor->mtd, NULL, &ppdata,
+ 			data ? data->parts : NULL,
+ 			data ? data->nr_parts : 0);
+ }
+@@ -257,64 +240,68 @@ static int m25p_remove(struct spi_device
+ 	struct m25p	*flash = spi_get_drvdata(spi);
+ 
+ 	/* Clean up MTD stuff. */
+-	return mtd_device_unregister(&flash->mtd);
++	return mtd_device_unregister(&flash->spi_nor.mtd);
+ }
+ 
+-
+ /*
+- * XXX This needs to be kept in sync with spi_nor_ids.  We can't share
+- * it with spi-nor, because if this is built as a module then modpost
+- * won't be able to read it and add appropriate aliases.
++ * Do NOT add to this array without reading the following:
++ *
++ * Historically, many flash devices are bound to this driver by their name. But
++ * since most of these flash are compatible to some extent, and their
++ * differences can often be differentiated by the JEDEC read-ID command, we
++ * encourage new users to add support to the spi-nor library, and simply bind
++ * against a generic string here (e.g., "jedec,spi-nor").
++ *
++ * Many flash names are kept here in this list (as well as in spi-nor.c) to
++ * keep them available as module aliases for existing platforms.
+  */
+ static const struct spi_device_id m25p_ids[] = {
+-	{"at25fs010"},	{"at25fs040"},	{"at25df041a"},	{"at25df321a"},
+-	{"at25df641"},	{"at26f004"},	{"at26df081a"},	{"at26df161a"},
+-	{"at26df321"},	{"at45db081d"},
+-	{"en25f32"},	{"en25p32"},	{"en25q32b"},	{"en25p64"},
+-	{"en25q64"},	{"en25qh128"},	{"en25qh256"},
+-	{"f25l32pa"},
+-	{"mr25h256"},	{"mr25h10"},
+-	{"gd25q32"},	{"gd25q64"},
+-	{"160s33b"},	{"320s33b"},	{"640s33b"},
+-	{"mx25l2005a"},	{"mx25l4005a"},	{"mx25l8005"},	{"mx25l1606e"},
+-	{"mx25l3205d"},	{"mx25l3255e"},	{"mx25l6405d"},	{"mx25l12805d"},
+-	{"mx25l12855e"},{"mx25l25635e"},{"mx25l25655e"},{"mx66l51235l"},
+-	{"mx66l1g55g"},
+-	{"n25q064"},	{"n25q128a11"},	{"n25q128a13"},	{"n25q256a"},
+-	{"n25q512a"},	{"n25q512ax3"},	{"n25q00"},
+-	{"pm25lv512"},	{"pm25lv010"},	{"pm25lq032"},
+-	{"s25sl032p"},	{"s25sl064p"},	{"s25fl256s0"},	{"s25fl256s1"},
+-	{"s25fl512s"},	{"s70fl01gs"},	{"s25sl12800"},	{"s25sl12801"},
+-	{"s25fl129p0"},	{"s25fl129p1"},	{"s25sl004a"},	{"s25sl008a"},
+-	{"s25sl016a"},	{"s25sl032a"},	{"s25sl064a"},	{"s25fl008k"},
+-	{"s25fl016k"},	{"s25fl064k"},
+-	{"sst25vf040b"},{"sst25vf080b"},{"sst25vf016b"},{"sst25vf032b"},
+-	{"sst25vf064c"},{"sst25wf512"},	{"sst25wf010"},	{"sst25wf020"},
+-	{"sst25wf040"},
+-	{"m25p05"},	{"m25p10"},	{"m25p20"},	{"m25p40"},
+-	{"m25p80"},	{"m25p16"},	{"m25p32"},	{"m25p64"},
+-	{"m25p128"},	{"n25q032"},
++	/*
++	 * Entries not used in DTs that should be safe to drop after replacing
++	 * them with "nor-jedec" in platform data.
++	 */
++	{"s25sl064a"},	{"w25x16"},	{"m25p10"},	{"m25px64"},
++
++	/*
++	 * Entries that were used in DTs without "nor-jedec" fallback and should
++	 * be kept for backward compatibility.
++	 */
++	{"at25df321a"},	{"at25df641"},	{"at26df081a"},
++	{"mr25h256"},
++	{"mx25l4005a"},	{"mx25l1606e"},	{"mx25l6405d"},	{"mx25l12805d"},
++	{"mx25l25635e"},{"mx66l51235l"},
++	{"n25q064"},	{"n25q128a11"},	{"n25q128a13"},	{"n25q512a"},
++	{"s25fl256s1"},	{"s25fl512s"},	{"s25sl12801"},	{"s25fl008k"},
++	{"s25fl064k"},
++	{"sst25vf040b"},{"sst25vf016b"},{"sst25vf032b"},{"sst25wf040"},
++	{"m25p40"},	{"m25p80"},	{"m25p16"},	{"m25p32"},
++	{"m25p64"},	{"m25p128"},
++	{"w25x80"},	{"w25x32"},	{"w25q32"},	{"w25q32dw"},
++	{"w25q80bl"},	{"w25q128"},	{"w25q256"},
++
++	/* Flashes that can't be detected using JEDEC */
+ 	{"m25p05-nonjedec"},	{"m25p10-nonjedec"},	{"m25p20-nonjedec"},
+ 	{"m25p40-nonjedec"},	{"m25p80-nonjedec"},	{"m25p16-nonjedec"},
+ 	{"m25p32-nonjedec"},	{"m25p64-nonjedec"},	{"m25p128-nonjedec"},
+-	{"m45pe10"},	{"m45pe80"},	{"m45pe16"},
+-	{"m25pe20"},	{"m25pe80"},	{"m25pe16"},
+-	{"m25px16"},	{"m25px32"},	{"m25px32-s0"},	{"m25px32-s1"},
+-	{"m25px64"},	{"m25px80"},
+-	{"w25x10"},	{"w25x20"},	{"w25x40"},	{"w25x80"},
+-	{"w25x16"},	{"w25x32"},	{"w25q32"},	{"w25q32dw"},
+-	{"w25x64"},	{"w25q64"},	{"w25q80"},	{"w25q80bl"},
+-	{"w25q128"},	{"w25q256"},	{"cat25c11"},
+-	{"cat25c03"},	{"cat25c09"},	{"cat25c17"},	{"cat25128"},
++
+ 	{ },
+ };
+ MODULE_DEVICE_TABLE(spi, m25p_ids);
+ 
++static const struct of_device_id m25p_of_table[] = {
++	/*
++	 * Generic compatibility for SPI NOR that can be identified by the
++	 * JEDEC READ ID opcode (0x9F). Use this, if possible.
++	 */
++	{ .compatible = "jedec,spi-nor" },
++	{}
++};
++MODULE_DEVICE_TABLE(of, m25p_of_table);
+ 
+ static struct spi_driver m25p80_driver = {
+ 	.driver = {
+ 		.name	= "m25p80",
+-		.owner	= THIS_MODULE,
++		.of_match_table = m25p_of_table,
+ 	},
+ 	.id_table	= m25p_ids,
+ 	.probe	= m25p_probe,
+--- a/drivers/mtd/spi-nor/spi-nor.c
++++ b/drivers/mtd/spi-nor/spi-nor.c
+@@ -16,19 +16,63 @@
+ #include <linux/device.h>
+ #include <linux/mutex.h>
+ #include <linux/math64.h>
++#include <linux/sizes.h>
+ 
+-#include <linux/mtd/cfi.h>
+ #include <linux/mtd/mtd.h>
+ #include <linux/of_platform.h>
+ #include <linux/spi/flash.h>
+ #include <linux/mtd/spi-nor.h>
+ 
+ /* Define max times to check status register before we give up. */
+-#define	MAX_READY_WAIT_JIFFIES	(40 * HZ) /* M25P16 specs 40s max chip erase */
+ 
+-#define JEDEC_MFR(_jedec_id)	((_jedec_id) >> 16)
++/*
++ * For everything but full-chip erase; probably could be much smaller, but kept
++ * around for safety for now
++ */
++#define DEFAULT_READY_WAIT_JIFFIES		(40UL * HZ)
++
++/*
++ * For full-chip erase, calibrated to a 2MB flash (M25P16); should be scaled up
++ * for larger flash
++ */
++#define CHIP_ERASE_2MB_READY_WAIT_JIFFIES	(40UL * HZ)
++
++#define SPI_NOR_MAX_ID_LEN	6
++
++struct flash_info {
++	char		*name;
++
++	/*
++	 * This array stores the ID bytes.
++	 * The first three bytes are the JEDIC ID.
++	 * JEDEC ID zero means "no ID" (mostly older chips).
++	 */
++	u8		id[SPI_NOR_MAX_ID_LEN];
++	u8		id_len;
++
++	/* The size listed here is what works with SPINOR_OP_SE, which isn't
++	 * necessarily called a "sector" by the vendor.
++	 */
++	unsigned	sector_size;
++	u16		n_sectors;
++
++	u16		page_size;
++	u16		addr_width;
++
++	u16		flags;
++#define	SECT_4K			0x01	/* SPINOR_OP_BE_4K works uniformly */
++#define	SPI_NOR_NO_ERASE	0x02	/* No erase command needed */
++#define	SST_WRITE		0x04	/* use SST byte programming */
++#define	SPI_NOR_NO_FR		0x08	/* Can't do fastread */
++#define	SECT_4K_PMC		0x10	/* SPINOR_OP_BE_4K_PMC works uniformly */
++#define	SPI_NOR_DUAL_READ	0x20    /* Flash supports Dual Read */
++#define	SPI_NOR_QUAD_READ	0x40    /* Flash supports Quad Read */
++#define	USE_FSR			0x80	/* use flag status register */
++};
+ 
+-static const struct spi_device_id *spi_nor_match_id(const char *name);
++#define JEDEC_MFR(info)	((info)->id[0])
++
++static const struct flash_info *spi_nor_match_id(const char *name);
+ 
+ /*
+  * Read the status register, returning its value in the location
+@@ -98,7 +142,7 @@ static inline int spi_nor_read_dummy_cyc
+ 	case SPI_NOR_FAST:
+ 	case SPI_NOR_DUAL:
+ 	case SPI_NOR_QUAD:
+-		return 1;
++		return 8;
+ 	case SPI_NOR_NORMAL:
+ 		return 0;
+ 	}
+@@ -112,7 +156,7 @@ static inline int spi_nor_read_dummy_cyc
+ static inline int write_sr(struct spi_nor *nor, u8 val)
+ {
+ 	nor->cmd_buf[0] = val;
+-	return nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 1, 0);
++	return nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 1);
+ }
+ 
+ /*
+@@ -121,7 +165,7 @@ static inline int write_sr(struct spi_no
+  */
+ static inline int write_enable(struct spi_nor *nor)
+ {
+-	return nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0, 0);
++	return nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0);
+ }
+ 
+ /*
+@@ -129,7 +173,7 @@ static inline int write_enable(struct sp
+  */
+ static inline int write_disable(struct spi_nor *nor)
+ {
+-	return nor->write_reg(nor, SPINOR_OP_WRDI, NULL, 0, 0);
++	return nor->write_reg(nor, SPINOR_OP_WRDI, NULL, 0);
+ }
+ 
+ static inline struct spi_nor *mtd_to_spi_nor(struct mtd_info *mtd)
+@@ -138,23 +182,24 @@ static inline struct spi_nor *mtd_to_spi
+ }
+ 
+ /* Enable/disable 4-byte addressing mode. */
+-static inline int set_4byte(struct spi_nor *nor, u32 jedec_id, int enable)
++static inline int set_4byte(struct spi_nor *nor, const struct flash_info *info,
++			    int enable)
+ {
+ 	int status;
+ 	bool need_wren = false;
+ 	u8 cmd;
+ 
+-	switch (JEDEC_MFR(jedec_id)) {
+-	case CFI_MFR_ST: /* Micron, actually */
++	switch (JEDEC_MFR(info)) {
++	case SNOR_MFR_MICRON:
+ 		/* Some Micron need WREN command; all will accept it */
+ 		need_wren = true;
+-	case CFI_MFR_MACRONIX:
+-	case 0xEF /* winbond */:
++	case SNOR_MFR_MACRONIX:
++	case SNOR_MFR_WINBOND:
+ 		if (need_wren)
+ 			write_enable(nor);
+ 
+ 		cmd = enable ? SPINOR_OP_EN4B : SPINOR_OP_EX4B;
+-		status = nor->write_reg(nor, cmd, NULL, 0, 0);
++		status = nor->write_reg(nor, cmd, NULL, 0);
+ 		if (need_wren)
+ 			write_disable(nor);
+ 
+@@ -162,63 +207,73 @@ static inline int set_4byte(struct spi_n
+ 	default:
+ 		/* Spansion style */
+ 		nor->cmd_buf[0] = enable << 7;
+-		return nor->write_reg(nor, SPINOR_OP_BRWR, nor->cmd_buf, 1, 0);
++		return nor->write_reg(nor, SPINOR_OP_BRWR, nor->cmd_buf, 1);
+ 	}
+ }
+-
+-static int spi_nor_wait_till_ready(struct spi_nor *nor)
++static inline int spi_nor_sr_ready(struct spi_nor *nor)
+ {
+-	unsigned long deadline;
+-	int sr;
+-
+-	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
+-
+-	do {
+-		cond_resched();
++	int sr = read_sr(nor);
++	if (sr < 0)
++		return sr;
++	else
++		return !(sr & SR_WIP);
++}
+ 
+-		sr = read_sr(nor);
+-		if (sr < 0)
+-			break;
+-		else if (!(sr & SR_WIP))
+-			return 0;
+-	} while (!time_after_eq(jiffies, deadline));
++static inline int spi_nor_fsr_ready(struct spi_nor *nor)
++{
++	int fsr = read_fsr(nor);
++	if (fsr < 0)
++		return fsr;
++	else
++		return fsr & FSR_READY;
++}
+ 
+-	return -ETIMEDOUT;
++static int spi_nor_ready(struct spi_nor *nor)
++{
++	int sr, fsr;
++	sr = spi_nor_sr_ready(nor);
++	if (sr < 0)
++		return sr;
++	fsr = nor->flags & SNOR_F_USE_FSR ? spi_nor_fsr_ready(nor) : 1;
++	if (fsr < 0)
++		return fsr;
++	return sr && fsr;
+ }
+ 
+-static int spi_nor_wait_till_fsr_ready(struct spi_nor *nor)
++/*
++ * Service routine to read status register until ready, or timeout occurs.
++ * Returns non-zero if error.
++ */
++static int spi_nor_wait_till_ready_with_timeout(struct spi_nor *nor,
++						unsigned long timeout_jiffies)
+ {
+ 	unsigned long deadline;
+-	int sr;
+-	int fsr;
++	int timeout = 0, ret;
+ 
+-	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
++	deadline = jiffies + timeout_jiffies;
++
++	while (!timeout) {
++		if (time_after_eq(jiffies, deadline))
++			timeout = 1;
++
++		ret = spi_nor_ready(nor);
++		if (ret < 0)
++			return ret;
++		if (ret)
++			return 0;
+ 
+-	do {
+ 		cond_resched();
++	}
+ 
+-		sr = read_sr(nor);
+-		if (sr < 0) {
+-			break;
+-		} else if (!(sr & SR_WIP)) {
+-			fsr = read_fsr(nor);
+-			if (fsr < 0)
+-				break;
+-			if (fsr & FSR_READY)
+-				return 0;
+-		}
+-	} while (!time_after_eq(jiffies, deadline));
++	dev_err(nor->dev, "flash operation timed out\n");
+ 
+ 	return -ETIMEDOUT;
+ }
+ 
+-/*
+- * Service routine to read status register until ready, or timeout occurs.
+- * Returns non-zero if error.
+- */
+-static int wait_till_ready(struct spi_nor *nor)
++static int spi_nor_wait_till_ready(struct spi_nor *nor)
+ {
+-	return nor->wait_till_ready(nor);
++	return spi_nor_wait_till_ready_with_timeout(nor,
++						    DEFAULT_READY_WAIT_JIFFIES);
+ }
+ 
+ /*
+@@ -228,19 +283,9 @@ static int wait_till_ready(struct spi_no
+  */
+ static int erase_chip(struct spi_nor *nor)
+ {
+-	int ret;
+-
+-	dev_dbg(nor->dev, " %lldKiB\n", (long long)(nor->mtd->size >> 10));
++	dev_dbg(nor->dev, " %lldKiB\n", (long long)(nor->mtd.size >> 10));
+ 
+-	/* Wait until finished previous write command. */
+-	ret = wait_till_ready(nor);
+-	if (ret)
+-		return ret;
+-
+-	/* Send write enable, then erase commands. */
+-	write_enable(nor);
+-
+-	return nor->write_reg(nor, SPINOR_OP_CHIP_ERASE, NULL, 0, 0);
++	return nor->write_reg(nor, SPINOR_OP_CHIP_ERASE, NULL, 0);
+ }
+ 
+ static int spi_nor_lock_and_prep(struct spi_nor *nor, enum spi_nor_ops ops)
+@@ -294,11 +339,28 @@ static int spi_nor_erase(struct mtd_info
+ 
+ 	/* whole-chip erase? */
+ 	if (len == mtd->size) {
++		unsigned long timeout;
++
++		write_enable(nor);
++
+ 		if (erase_chip(nor)) {
+ 			ret = -EIO;
+ 			goto erase_err;
+ 		}
+ 
++		/*
++		 * Scale the timeout linearly with the size of the flash, with
++		 * a minimum calibrated to an old 2MB flash. We could try to
++		 * pull these from CFI/SFDP, but these values should be good
++		 * enough for now.
++		 */
++		timeout = max(CHIP_ERASE_2MB_READY_WAIT_JIFFIES,
++			      CHIP_ERASE_2MB_READY_WAIT_JIFFIES *
++			      (unsigned long)(mtd->size / SZ_2M));
++		ret = spi_nor_wait_till_ready_with_timeout(nor, timeout);
++		if (ret)
++			goto erase_err;
++
+ 	/* REVISIT in some cases we could speed up erasing large regions
+ 	 * by using SPINOR_OP_SE instead of SPINOR_OP_BE_4K.  We may have set up
+ 	 * to use "small sector erase", but that's not always optimal.
+@@ -307,6 +369,8 @@ static int spi_nor_erase(struct mtd_info
+ 	/* "sector"-at-a-time erase */
+ 	} else {
+ 		while (len) {
++			write_enable(nor);
++
+ 			if (nor->erase(nor, addr)) {
+ 				ret = -EIO;
+ 				goto erase_err;
+@@ -314,9 +378,15 @@ static int spi_nor_erase(struct mtd_info
+ 
+ 			addr += mtd->erasesize;
+ 			len -= mtd->erasesize;
++
++			ret = spi_nor_wait_till_ready(nor);
++			if (ret)
++				goto erase_err;
+ 		}
+ 	}
+ 
++	write_disable(nor);
++
+ 	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_ERASE);
+ 
+ 	instr->state = MTD_ERASE_DONE;
+@@ -330,152 +400,267 @@ erase_err:
+ 	return ret;
+ }
+ 
+-static int spi_nor_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
++static void stm_get_locked_range(struct spi_nor *nor, u8 sr, loff_t *ofs,
++				 uint64_t *len)
+ {
+-	struct spi_nor *nor = mtd_to_spi_nor(mtd);
+-	uint32_t offset = ofs;
+-	uint8_t status_old, status_new;
+-	int ret = 0;
++	struct mtd_info *mtd = &nor->mtd;
++	u8 mask = SR_BP2 | SR_BP1 | SR_BP0;
++	int shift = ffs(mask) - 1;
++	int pow;
++
++	if (!(sr & mask)) {
++		/* No protection */
++		*ofs = 0;
++		*len = 0;
++	} else {
++		pow = ((sr & mask) ^ mask) >> shift;
++		*len = mtd->size >> pow;
++		*ofs = mtd->size - *len;
++	}
++}
+ 
+-	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_LOCK);
+-	if (ret)
+-		return ret;
++/*
++ * Return 1 if the entire region is locked, 0 otherwise
++ */
++static int stm_is_locked_sr(struct spi_nor *nor, loff_t ofs, uint64_t len,
++			    u8 sr)
++{
++	loff_t lock_offs;
++	uint64_t lock_len;
+ 
+-	/* Wait until finished previous command */
+-	ret = wait_till_ready(nor);
+-	if (ret)
+-		goto err;
++	stm_get_locked_range(nor, sr, &lock_offs, &lock_len);
++
++	return (ofs + len <= lock_offs + lock_len) && (ofs >= lock_offs);
++}
++
++/*
++ * Lock a region of the flash. Compatible with ST Micro and similar flash.
++ * Supports only the block protection bits BP{0,1,2} in the status register
++ * (SR). Does not support these features found in newer SR bitfields:
++ *   - TB: top/bottom protect - only handle TB=0 (top protect)
++ *   - SEC: sector/block protect - only handle SEC=0 (block protect)
++ *   - CMP: complement protect - only support CMP=0 (range is not complemented)
++ *
++ * Sample table portion for 8MB flash (Winbond w25q64fw):
++ *
++ *   SEC  |  TB   |  BP2  |  BP1  |  BP0  |  Prot Length  | Protected Portion
++ *  --------------------------------------------------------------------------
++ *    X   |   X   |   0   |   0   |   0   |  NONE         | NONE
++ *    0   |   0   |   0   |   0   |   1   |  128 KB       | Upper 1/64
++ *    0   |   0   |   0   |   1   |   0   |  256 KB       | Upper 1/32
++ *    0   |   0   |   0   |   1   |   1   |  512 KB       | Upper 1/16
++ *    0   |   0   |   1   |   0   |   0   |  1 MB         | Upper 1/8
++ *    0   |   0   |   1   |   0   |   1   |  2 MB         | Upper 1/4
++ *    0   |   0   |   1   |   1   |   0   |  4 MB         | Upper 1/2
++ *    X   |   X   |   1   |   1   |   1   |  8 MB         | ALL
++ *
++ * Returns negative on errors, 0 on success.
++ */
++static int stm_lock(struct spi_nor *nor, loff_t ofs, uint64_t len)
++{
++	struct mtd_info *mtd = &nor->mtd;
++	u8 status_old, status_new;
++	u8 mask = SR_BP2 | SR_BP1 | SR_BP0;
++	u8 shift = ffs(mask) - 1, pow, val;
+ 
+ 	status_old = read_sr(nor);
+ 
+-	if (offset < mtd->size - (mtd->size / 2))
+-		status_new = status_old | SR_BP2 | SR_BP1 | SR_BP0;
+-	else if (offset < mtd->size - (mtd->size / 4))
+-		status_new = (status_old & ~SR_BP0) | SR_BP2 | SR_BP1;
+-	else if (offset < mtd->size - (mtd->size / 8))
+-		status_new = (status_old & ~SR_BP1) | SR_BP2 | SR_BP0;
+-	else if (offset < mtd->size - (mtd->size / 16))
+-		status_new = (status_old & ~(SR_BP0 | SR_BP1)) | SR_BP2;
+-	else if (offset < mtd->size - (mtd->size / 32))
+-		status_new = (status_old & ~SR_BP2) | SR_BP1 | SR_BP0;
+-	else if (offset < mtd->size - (mtd->size / 64))
+-		status_new = (status_old & ~(SR_BP2 | SR_BP0)) | SR_BP1;
+-	else
+-		status_new = (status_old & ~(SR_BP2 | SR_BP1)) | SR_BP0;
++	/* SPI NOR always locks to the end */
++	if (ofs + len != mtd->size) {
++		/* Does combined region extend to end? */
++		if (!stm_is_locked_sr(nor, ofs + len, mtd->size - ofs - len,
++				      status_old))
++			return -EINVAL;
++		len = mtd->size - ofs;
++	}
++
++	/*
++	 * Need smallest pow such that:
++	 *
++	 *   1 / (2^pow) <= (len / size)
++	 *
++	 * so (assuming power-of-2 size) we do:
++	 *
++	 *   pow = ceil(log2(size / len)) = log2(size) - floor(log2(len))
++	 */
++	pow = ilog2(mtd->size) - ilog2(len);
++	val = mask - (pow << shift);
++	if (val & ~mask)
++		return -EINVAL;
++	/* Don't "lock" with no region! */
++	if (!(val & mask))
++		return -EINVAL;
++
++	status_new = (status_old & ~mask) | val;
+ 
+ 	/* Only modify protection if it will not unlock other areas */
+-	if ((status_new & (SR_BP2 | SR_BP1 | SR_BP0)) >
+-				(status_old & (SR_BP2 | SR_BP1 | SR_BP0))) {
+-		write_enable(nor);
+-		ret = write_sr(nor, status_new);
+-		if (ret)
+-			goto err;
++	if ((status_new & mask) <= (status_old & mask))
++		return -EINVAL;
++
++	write_enable(nor);
++	return write_sr(nor, status_new);
++}
++
++/*
++ * Unlock a region of the flash. See stm_lock() for more info
++ *
++ * Returns negative on errors, 0 on success.
++ */
++static int stm_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)
++{
++	struct mtd_info *mtd = &nor->mtd;
++	uint8_t status_old, status_new;
++	u8 mask = SR_BP2 | SR_BP1 | SR_BP0;
++	u8 shift = ffs(mask) - 1, pow, val;
++
++	status_old = read_sr(nor);
++
++	/* Cannot unlock; would unlock larger region than requested */
++	if (stm_is_locked_sr(nor, ofs - mtd->erasesize, mtd->erasesize,
++			     status_old))
++		return -EINVAL;
++
++	/*
++	 * Need largest pow such that:
++	 *
++	 *   1 / (2^pow) >= (len / size)
++	 *
++	 * so (assuming power-of-2 size) we do:
++	 *
++	 *   pow = floor(log2(size / len)) = log2(size) - ceil(log2(len))
++	 */
++	pow = ilog2(mtd->size) - order_base_2(mtd->size - (ofs + len));
++	if (ofs + len == mtd->size) {
++		val = 0; /* fully unlocked */
++	} else {
++		val = mask - (pow << shift);
++		/* Some power-of-two sizes are not supported */
++		if (val & ~mask)
++			return -EINVAL;
+ 	}
+ 
+-err:
+-	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_LOCK);
+-	return ret;
++	status_new = (status_old & ~mask) | val;
++
++	/* Only modify protection if it will not lock other areas */
++	if ((status_new & mask) >= (status_old & mask))
++		return -EINVAL;
++
++	write_enable(nor);
++	return write_sr(nor, status_new);
+ }
+ 
+-static int spi_nor_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
++/*
++ * Check if a region of the flash is (completely) locked. See stm_lock() for
++ * more info.
++ *
++ * Returns 1 if entire region is locked, 0 if any portion is unlocked, and
++ * negative on errors.
++ */
++static int stm_is_locked(struct spi_nor *nor, loff_t ofs, uint64_t len)
++{
++	int status;
++
++	status = read_sr(nor);
++	if (status < 0)
++		return status;
++
++	return stm_is_locked_sr(nor, ofs, len, status);
++}
++
++static int spi_nor_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
+ {
+ 	struct spi_nor *nor = mtd_to_spi_nor(mtd);
+-	uint32_t offset = ofs;
+-	uint8_t status_old, status_new;
+-	int ret = 0;
++	int ret;
+ 
+-	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_UNLOCK);
++	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_LOCK);
+ 	if (ret)
+ 		return ret;
+ 
+-	/* Wait until finished previous command */
+-	ret = wait_till_ready(nor);
+-	if (ret)
+-		goto err;
++	ret = nor->flash_lock(nor, ofs, len);
+ 
+-	status_old = read_sr(nor);
++	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_UNLOCK);
++	return ret;
++}
+ 
+-	if (offset+len > mtd->size - (mtd->size / 64))
+-		status_new = status_old & ~(SR_BP2 | SR_BP1 | SR_BP0);
+-	else if (offset+len > mtd->size - (mtd->size / 32))
+-		status_new = (status_old & ~(SR_BP2 | SR_BP1)) | SR_BP0;
+-	else if (offset+len > mtd->size - (mtd->size / 16))
+-		status_new = (status_old & ~(SR_BP2 | SR_BP0)) | SR_BP1;
+-	else if (offset+len > mtd->size - (mtd->size / 8))
+-		status_new = (status_old & ~SR_BP2) | SR_BP1 | SR_BP0;
+-	else if (offset+len > mtd->size - (mtd->size / 4))
+-		status_new = (status_old & ~(SR_BP0 | SR_BP1)) | SR_BP2;
+-	else if (offset+len > mtd->size - (mtd->size / 2))
+-		status_new = (status_old & ~SR_BP1) | SR_BP2 | SR_BP0;
+-	else
+-		status_new = (status_old & ~SR_BP0) | SR_BP2 | SR_BP1;
++static int spi_nor_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
++{
++	struct spi_nor *nor = mtd_to_spi_nor(mtd);
++	int ret;
+ 
+-	/* Only modify protection if it will not lock other areas */
+-	if ((status_new & (SR_BP2 | SR_BP1 | SR_BP0)) <
+-				(status_old & (SR_BP2 | SR_BP1 | SR_BP0))) {
+-		write_enable(nor);
+-		ret = write_sr(nor, status_new);
+-		if (ret)
+-			goto err;
+-	}
++	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_UNLOCK);
++	if (ret)
++		return ret;
+ 
+-err:
+-	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_UNLOCK);
++	ret = nor->flash_unlock(nor, ofs, len);
++
++	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_LOCK);
+ 	return ret;
+ }
+ 
+-struct flash_info {
+-	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+-	 * a high byte of zero plus three data bytes: the manufacturer id,
+-	 * then a two byte device id.
+-	 */
+-	u32		jedec_id;
+-	u16             ext_id;
++static int spi_nor_is_locked(struct mtd_info *mtd, loff_t ofs, uint64_t len)
++{
++	struct spi_nor *nor = mtd_to_spi_nor(mtd);
++	int ret;
+ 
+-	/* The size listed here is what works with SPINOR_OP_SE, which isn't
+-	 * necessarily called a "sector" by the vendor.
+-	 */
+-	unsigned	sector_size;
+-	u16		n_sectors;
++	ret = spi_nor_lock_and_prep(nor, SPI_NOR_OPS_UNLOCK);
++	if (ret)
++		return ret;
+ 
+-	u16		page_size;
+-	u16		addr_width;
++	ret = nor->flash_is_locked(nor, ofs, len);
+ 
+-	u16		flags;
+-#define	SECT_4K			0x01	/* SPINOR_OP_BE_4K works uniformly */
+-#define	SPI_NOR_NO_ERASE	0x02	/* No erase command needed */
+-#define	SST_WRITE		0x04	/* use SST byte programming */
+-#define	SPI_NOR_NO_FR		0x08	/* Can't do fastread */
+-#define	SECT_4K_PMC		0x10	/* SPINOR_OP_BE_4K_PMC works uniformly */
+-#define	SPI_NOR_DUAL_READ	0x20    /* Flash supports Dual Read */
+-#define	SPI_NOR_QUAD_READ	0x40    /* Flash supports Quad Read */
+-#define	USE_FSR			0x80	/* use flag status register */
+-};
++	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_LOCK);
++	return ret;
++}
+ 
++/* Used when the "_ext_id" is two bytes at most */
+ #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
+-	((kernel_ulong_t)&(struct flash_info) {				\
+-		.jedec_id = (_jedec_id),				\
+-		.ext_id = (_ext_id),					\
++		.id = {							\
++			((_jedec_id) >> 16) & 0xff,			\
++			((_jedec_id) >> 8) & 0xff,			\
++			(_jedec_id) & 0xff,				\
++			((_ext_id) >> 8) & 0xff,			\
++			(_ext_id) & 0xff,				\
++			},						\
++		.id_len = (!(_jedec_id) ? 0 : (3 + ((_ext_id) ? 2 : 0))),	\
++		.sector_size = (_sector_size),				\
++		.n_sectors = (_n_sectors),				\
++		.page_size = 256,					\
++		.flags = (_flags),
++
++#define INFO6(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
++		.id = {							\
++			((_jedec_id) >> 16) & 0xff,			\
++			((_jedec_id) >> 8) & 0xff,			\
++			(_jedec_id) & 0xff,				\
++			((_ext_id) >> 16) & 0xff,			\
++			((_ext_id) >> 8) & 0xff,			\
++			(_ext_id) & 0xff,				\
++			},						\
++		.id_len = 6,						\
+ 		.sector_size = (_sector_size),				\
+ 		.n_sectors = (_n_sectors),				\
+ 		.page_size = 256,					\
+-		.flags = (_flags),					\
+-	})
++		.flags = (_flags),
+ 
+ #define CAT25_INFO(_sector_size, _n_sectors, _page_size, _addr_width, _flags)	\
+-	((kernel_ulong_t)&(struct flash_info) {				\
+ 		.sector_size = (_sector_size),				\
+ 		.n_sectors = (_n_sectors),				\
+ 		.page_size = (_page_size),				\
+ 		.addr_width = (_addr_width),				\
+-		.flags = (_flags),					\
+-	})
++		.flags = (_flags),
+ 
+ /* NOTE: double check command sets and memory organization when you add
+  * more nor chips.  This current list focusses on newer chips, which
+  * have been converging on command sets which including JEDEC ID.
++ *
++ * All newly added entries should describe *hardware* and should use SECT_4K
++ * (or SECT_4K_PMC) if hardware supports erasing 4 KiB sectors. For usage
++ * scenarios excluding small sectors there is config option that can be
++ * disabled: CONFIG_MTD_SPI_NOR_USE_4K_SECTORS.
++ * For historical (and compatibility) reasons (before we got above config) some
++ * old entries may be missing 4K flag.
+  */
+-static const struct spi_device_id spi_nor_ids[] = {
++static const struct flash_info spi_nor_ids[] = {
+ 	/* Atmel -- some are (confusingly) marketed as "DataFlash" */
+ 	{ "at25fs010",  INFO(0x1f6601, 0, 32 * 1024,   4, SECT_4K) },
+ 	{ "at25fs040",  INFO(0x1f6604, 0, 64 * 1024,   8, SECT_4K) },
+@@ -499,6 +684,7 @@ static const struct spi_device_id spi_no
+ 	{ "en25q64",    INFO(0x1c3017, 0, 64 * 1024,  128, SECT_4K) },
+ 	{ "en25qh128",  INFO(0x1c7018, 0, 64 * 1024,  256, 0) },
+ 	{ "en25qh256",  INFO(0x1c7019, 0, 64 * 1024,  512, 0) },
++	{ "en25s64",	INFO(0x1c3817, 0, 64 * 1024,  128, SECT_4K) },
+ 
+ 	/* ESMT */
+ 	{ "f25l32pa", INFO(0x8c2016, 0, 64 * 1024, 64, SECT_4K) },
+@@ -507,16 +693,24 @@ static const struct spi_device_id spi_no
+ 	{ "mr25h256", CAT25_INFO( 32 * 1024, 1, 256, 2, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
+ 	{ "mr25h10",  CAT25_INFO(128 * 1024, 1, 256, 3, SPI_NOR_NO_ERASE | SPI_NOR_NO_FR) },
+ 
++	/* Fujitsu */
++	{ "mb85rs1mt", INFO(0x047f27, 0, 128 * 1024, 1, SPI_NOR_NO_ERASE) },
++
+ 	/* GigaDevice */
+ 	{ "gd25q32", INFO(0xc84016, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "gd25q64", INFO(0xc84017, 0, 64 * 1024, 128, SECT_4K) },
++	{ "gd25q128", INFO(0xc84018, 0, 64 * 1024, 256, SECT_4K) },
+ 
+ 	/* Intel/Numonyx -- xxxs33b */
+ 	{ "160s33b",  INFO(0x898911, 0, 64 * 1024,  32, 0) },
+ 	{ "320s33b",  INFO(0x898912, 0, 64 * 1024,  64, 0) },
+ 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
+ 
++	/* ISSI */
++	{ "is25cd512", INFO(0x7f9d20, 0, 32 * 1024,   2, SECT_4K) },
++
+ 	/* Macronix */
++	{ "mx25l512e",   INFO(0xc22010, 0, 64 * 1024,   1, SECT_4K) },
+ 	{ "mx25l2005a",  INFO(0xc22012, 0, 64 * 1024,   4, SECT_4K) },
+ 	{ "mx25l4005a",  INFO(0xc22013, 0, 64 * 1024,   8, SECT_4K) },
+ 	{ "mx25l8005",   INFO(0xc22014, 0, 64 * 1024,  16, 0) },
+@@ -524,6 +718,7 @@ static const struct spi_device_id spi_no
+ 	{ "mx25l3205d",  INFO(0xc22016, 0, 64 * 1024,  64, 0) },
+ 	{ "mx25l3255e",  INFO(0xc29e16, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "mx25l6405d",  INFO(0xc22017, 0, 64 * 1024, 128, 0) },
++	{ "mx25u6435f",  INFO(0xc22537, 0, 64 * 1024, 128, SECT_4K) },
+ 	{ "mx25l12805d", INFO(0xc22018, 0, 64 * 1024, 256, 0) },
+ 	{ "mx25l12855e", INFO(0xc22618, 0, 64 * 1024, 256, 0) },
+ 	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
+@@ -532,13 +727,16 @@ static const struct spi_device_id spi_no
+ 	{ "mx66l1g55g",  INFO(0xc2261b, 0, 64 * 1024, 2048, SPI_NOR_QUAD_READ) },
+ 
+ 	/* Micron */
+-	{ "n25q064",     INFO(0x20ba17, 0, 64 * 1024,  128, 0) },
+-	{ "n25q128a11",  INFO(0x20bb18, 0, 64 * 1024,  256, 0) },
+-	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024,  256, 0) },
+-	{ "n25q256a",    INFO(0x20ba19, 0, 64 * 1024,  512, SECT_4K) },
+-	{ "n25q512a",    INFO(0x20bb20, 0, 64 * 1024, 1024, SECT_4K) },
+-	{ "n25q512ax3",  INFO(0x20ba20, 0, 64 * 1024, 1024, USE_FSR) },
+-	{ "n25q00",      INFO(0x20ba21, 0, 64 * 1024, 2048, USE_FSR) },
++	{ "n25q032",	 INFO(0x20ba16, 0, 64 * 1024,   64, SPI_NOR_QUAD_READ) },
++	{ "n25q032a",	 INFO(0x20bb16, 0, 64 * 1024,   64, SPI_NOR_QUAD_READ) },
++	{ "n25q064",     INFO(0x20ba17, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_QUAD_READ) },
++	{ "n25q064a",    INFO(0x20bb17, 0, 64 * 1024,  128, SECT_4K | SPI_NOR_QUAD_READ) },
++	{ "n25q128a11",  INFO(0x20bb18, 0, 64 * 1024,  256, SPI_NOR_QUAD_READ) },
++	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024,  256, SPI_NOR_QUAD_READ) },
++	{ "n25q256a",    INFO(0x20ba19, 0, 64 * 1024,  512, SECT_4K | SPI_NOR_QUAD_READ) },
++	{ "n25q512a",    INFO(0x20bb20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ) },
++	{ "n25q512ax3",  INFO(0x20ba20, 0, 64 * 1024, 1024, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ) },
++	{ "n25q00",      INFO(0x20ba21, 0, 64 * 1024, 2048, SECT_4K | USE_FSR | SPI_NOR_QUAD_READ) },
+ 
+ 	/* PMC */
+ 	{ "pm25lv512",   INFO(0,        0, 32 * 1024,    2, SECT_4K_PMC) },
+@@ -549,23 +747,28 @@ static const struct spi_device_id spi_no
+ 	 * for the chips listed here (without boot sectors).
+ 	 */
+ 	{ "s25sl032p",  INFO(0x010215, 0x4d00,  64 * 1024,  64, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+-	{ "s25sl064p",  INFO(0x010216, 0x4d00,  64 * 1024, 128, 0) },
++	{ "s25sl064p",  INFO(0x010216, 0x4d00,  64 * 1024, 128, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ "s25fl256s0", INFO(0x010219, 0x4d00, 256 * 1024, 128, 0) },
+ 	{ "s25fl256s1", INFO(0x010219, 0x4d01,  64 * 1024, 512, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ "s25fl512s",  INFO(0x010220, 0x4d00, 256 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ "s70fl01gs",  INFO(0x010221, 0x4d00, 256 * 1024, 256, 0) },
+ 	{ "s25sl12800", INFO(0x012018, 0x0300, 256 * 1024,  64, 0) },
+ 	{ "s25sl12801", INFO(0x012018, 0x0301,  64 * 1024, 256, 0) },
+-	{ "s25fl129p0", INFO(0x012018, 0x4d00, 256 * 1024,  64, 0) },
+-	{ "s25fl129p1", INFO(0x012018, 0x4d01,  64 * 1024, 256, 0) },
++	{ "s25fl128s",	INFO6(0x012018, 0x4d0180, 64 * 1024, 256, SECT_4K | SPI_NOR_QUAD_READ) },
++	{ "s25fl129p0", INFO(0x012018, 0x4d00, 256 * 1024,  64, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
++	{ "s25fl129p1", INFO(0x012018, 0x4d01,  64 * 1024, 256, SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ "s25sl004a",  INFO(0x010212,      0,  64 * 1024,   8, 0) },
+ 	{ "s25sl008a",  INFO(0x010213,      0,  64 * 1024,  16, 0) },
+ 	{ "s25sl016a",  INFO(0x010214,      0,  64 * 1024,  32, 0) },
+ 	{ "s25sl032a",  INFO(0x010215,      0,  64 * 1024,  64, 0) },
+ 	{ "s25sl064a",  INFO(0x010216,      0,  64 * 1024, 128, 0) },
+-	{ "s25fl008k",  INFO(0xef4014,      0,  64 * 1024,  16, SECT_4K) },
+-	{ "s25fl016k",  INFO(0xef4015,      0,  64 * 1024,  32, SECT_4K) },
++	{ "s25fl004k",  INFO(0xef4013,      0,  64 * 1024,   8, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
++	{ "s25fl008k",  INFO(0xef4014,      0,  64 * 1024,  16, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
++	{ "s25fl016k",  INFO(0xef4015,      0,  64 * 1024,  32, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ "s25fl064k",  INFO(0xef4017,      0,  64 * 1024, 128, SECT_4K) },
++	{ "s25fl132k",  INFO(0x014016,      0,  64 * 1024,  64, SECT_4K) },
++	{ "s25fl164k",  INFO(0x014017,      0,  64 * 1024, 128, SECT_4K) },
++	{ "s25fl204k",  INFO(0x014013,      0,  64 * 1024,   8, SECT_4K | SPI_NOR_DUAL_READ) },
+ 
+ 	/* SST -- large erase sizes are "overlays", "sectors" are 4K */
+ 	{ "sst25vf040b", INFO(0xbf258d, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
+@@ -576,7 +779,10 @@ static const struct spi_device_id spi_no
+ 	{ "sst25wf512",  INFO(0xbf2501, 0, 64 * 1024,  1, SECT_4K | SST_WRITE) },
+ 	{ "sst25wf010",  INFO(0xbf2502, 0, 64 * 1024,  2, SECT_4K | SST_WRITE) },
+ 	{ "sst25wf020",  INFO(0xbf2503, 0, 64 * 1024,  4, SECT_4K | SST_WRITE) },
++	{ "sst25wf020a", INFO(0x621612, 0, 64 * 1024,  4, SECT_4K) },
++	{ "sst25wf040b", INFO(0x621613, 0, 64 * 1024,  8, SECT_4K) },
+ 	{ "sst25wf040",  INFO(0xbf2504, 0, 64 * 1024,  8, SECT_4K | SST_WRITE) },
++	{ "sst25wf080",  INFO(0xbf2505, 0, 64 * 1024, 16, SECT_4K | SST_WRITE) },
+ 
+ 	/* ST Microelectronics -- newer production may have feature updates */
+ 	{ "m25p05",  INFO(0x202010,  0,  32 * 1024,   2, 0) },
+@@ -588,7 +794,6 @@ static const struct spi_device_id spi_no
+ 	{ "m25p32",  INFO(0x202016,  0,  64 * 1024,  64, 0) },
+ 	{ "m25p64",  INFO(0x202017,  0,  64 * 1024, 128, 0) },
+ 	{ "m25p128", INFO(0x202018,  0, 256 * 1024,  64, 0) },
+-	{ "n25q032", INFO(0x20ba16,  0,  64 * 1024,  64, 0) },
+ 
+ 	{ "m25p05-nonjedec",  INFO(0, 0,  32 * 1024,   2, 0) },
+ 	{ "m25p10-nonjedec",  INFO(0, 0,  32 * 1024,   4, 0) },
+@@ -616,6 +821,7 @@ static const struct spi_device_id spi_no
+ 	{ "m25px80",    INFO(0x207114,  0, 64 * 1024, 16, 0) },
+ 
+ 	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
++	{ "w25x05", INFO(0xef3010, 0, 64 * 1024,  1,  SECT_4K) },
+ 	{ "w25x10", INFO(0xef3011, 0, 64 * 1024,  2,  SECT_4K) },
+ 	{ "w25x20", INFO(0xef3012, 0, 64 * 1024,  4,  SECT_4K) },
+ 	{ "w25x40", INFO(0xef3013, 0, 64 * 1024,  8,  SECT_4K) },
+@@ -623,9 +829,11 @@ static const struct spi_device_id spi_no
+ 	{ "w25x16", INFO(0xef3015, 0, 64 * 1024,  32, SECT_4K) },
+ 	{ "w25x32", INFO(0xef3016, 0, 64 * 1024,  64, SECT_4K) },
+ 	{ "w25q32", INFO(0xef4016, 0, 64 * 1024,  64, SECT_4K) },
+-	{ "w25q32dw", INFO(0xef6016, 0, 64 * 1024,  64, SECT_4K) },
++	{ "w25q32dw", INFO(0xef6016, 0, 64 * 1024,  64, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ "w25x64", INFO(0xef3017, 0, 64 * 1024, 128, SECT_4K) },
+ 	{ "w25q64", INFO(0xef4017, 0, 64 * 1024, 128, SECT_4K) },
++	{ "w25q64dw", INFO(0xef6017, 0, 64 * 1024, 128, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
++	{ "w25q128fw", INFO(0xef6018, 0, 64 * 1024, 256, SECT_4K | SPI_NOR_DUAL_READ | SPI_NOR_QUAD_READ) },
+ 	{ "w25q80", INFO(0xef5014, 0, 64 * 1024,  16, SECT_4K) },
+ 	{ "w25q80bl", INFO(0xef4014, 0, 64 * 1024,  16, SECT_4K) },
+ 	{ "w25q128", INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K) },
+@@ -640,35 +848,27 @@ static const struct spi_device_id spi_no
+ 	{ },
+ };
+ 
+-static const struct spi_device_id *spi_nor_read_id(struct spi_nor *nor)
++static const struct flash_info *spi_nor_read_id(struct spi_nor *nor)
+ {
+ 	int			tmp;
+-	u8			id[5];
+-	u32			jedec;
+-	u16                     ext_jedec;
+-	struct flash_info	*info;
++	u8			id[SPI_NOR_MAX_ID_LEN];
++	const struct flash_info	*info;
+ 
+-	tmp = nor->read_reg(nor, SPINOR_OP_RDID, id, 5);
++	tmp = nor->read_reg(nor, SPINOR_OP_RDID, id, SPI_NOR_MAX_ID_LEN);
+ 	if (tmp < 0) {
+ 		dev_dbg(nor->dev, " error %d reading JEDEC ID\n", tmp);
+ 		return ERR_PTR(tmp);
+ 	}
+-	jedec = id[0];
+-	jedec = jedec << 8;
+-	jedec |= id[1];
+-	jedec = jedec << 8;
+-	jedec |= id[2];
+-
+-	ext_jedec = id[3] << 8 | id[4];
+ 
+ 	for (tmp = 0; tmp < ARRAY_SIZE(spi_nor_ids) - 1; tmp++) {
+-		info = (void *)spi_nor_ids[tmp].driver_data;
+-		if (info->jedec_id == jedec) {
+-			if (info->ext_id == 0 || info->ext_id == ext_jedec)
++		info = &spi_nor_ids[tmp];
++		if (info->id_len) {
++			if (!memcmp(info->id, id, info->id_len))
+ 				return &spi_nor_ids[tmp];
+ 		}
+ 	}
+-	dev_err(nor->dev, "unrecognized JEDEC id %06x\n", jedec);
++	dev_err(nor->dev, "unrecognized JEDEC id bytes: %02x, %2x, %2x\n",
++		id[0], id[1], id[2]);
+ 	return ERR_PTR(-ENODEV);
+ }
+ 
+@@ -703,11 +903,6 @@ static int sst_write(struct mtd_info *mt
+ 	if (ret)
+ 		return ret;
+ 
+-	/* Wait until finished previous write command. */
+-	ret = wait_till_ready(nor);
+-	if (ret)
+-		goto time_out;
+-
+ 	write_enable(nor);
+ 
+ 	nor->sst_write_second = false;
+@@ -719,7 +914,7 @@ static int sst_write(struct mtd_info *mt
+ 
+ 		/* write one byte. */
+ 		nor->write(nor, to, 1, retlen, buf);
+-		ret = wait_till_ready(nor);
++		ret = spi_nor_wait_till_ready(nor);
+ 		if (ret)
+ 			goto time_out;
+ 	}
+@@ -731,7 +926,7 @@ static int sst_write(struct mtd_info *mt
+ 
+ 		/* write two bytes. */
+ 		nor->write(nor, to, 2, retlen, buf + actual);
+-		ret = wait_till_ready(nor);
++		ret = spi_nor_wait_till_ready(nor);
+ 		if (ret)
+ 			goto time_out;
+ 		to += 2;
+@@ -740,7 +935,7 @@ static int sst_write(struct mtd_info *mt
+ 	nor->sst_write_second = false;
+ 
+ 	write_disable(nor);
+-	ret = wait_till_ready(nor);
++	ret = spi_nor_wait_till_ready(nor);
+ 	if (ret)
+ 		goto time_out;
+ 
+@@ -751,7 +946,7 @@ static int sst_write(struct mtd_info *mt
+ 		nor->program_opcode = SPINOR_OP_BP;
+ 		nor->write(nor, to, 1, retlen, buf + actual);
+ 
+-		ret = wait_till_ready(nor);
++		ret = spi_nor_wait_till_ready(nor);
+ 		if (ret)
+ 			goto time_out;
+ 		write_disable(nor);
+@@ -779,11 +974,6 @@ static int spi_nor_write(struct mtd_info
+ 	if (ret)
+ 		return ret;
+ 
+-	/* Wait until finished previous write command. */
+-	ret = wait_till_ready(nor);
+-	if (ret)
+-		goto write_err;
+-
+ 	write_enable(nor);
+ 
+ 	page_offset = to & (nor->page_size - 1);
+@@ -802,16 +992,20 @@ static int spi_nor_write(struct mtd_info
+ 			if (page_size > nor->page_size)
+ 				page_size = nor->page_size;
+ 
+-			wait_till_ready(nor);
++			ret = spi_nor_wait_till_ready(nor);
++			if (ret)
++				goto write_err;
++
+ 			write_enable(nor);
+ 
+ 			nor->write(nor, to + i, page_size, retlen, buf + i);
+ 		}
+ 	}
+ 
++	ret = spi_nor_wait_till_ready(nor);
+ write_err:
+ 	spi_nor_unlock_and_unprep(nor, SPI_NOR_OPS_WRITE);
+-	return 0;
++	return ret;
+ }
+ 
+ static int macronix_quad_enable(struct spi_nor *nor)
+@@ -821,10 +1015,9 @@ static int macronix_quad_enable(struct s
+ 	val = read_sr(nor);
+ 	write_enable(nor);
+ 
+-	nor->cmd_buf[0] = val | SR_QUAD_EN_MX;
+-	nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 1, 0);
++	write_sr(nor, val | SR_QUAD_EN_MX);
+ 
+-	if (wait_till_ready(nor))
++	if (spi_nor_wait_till_ready(nor))
+ 		return 1;
+ 
+ 	ret = read_sr(nor);
+@@ -847,7 +1040,7 @@ static int write_sr_cr(struct spi_nor *n
+ 	nor->cmd_buf[0] = val & 0xff;
+ 	nor->cmd_buf[1] = (val >> 8);
+ 
+-	return nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 2, 0);
++	return nor->write_reg(nor, SPINOR_OP_WRSR, nor->cmd_buf, 2);
+ }
+ 
+ static int spansion_quad_enable(struct spi_nor *nor)
+@@ -874,18 +1067,20 @@ static int spansion_quad_enable(struct s
+ 	return 0;
+ }
+ 
+-static int set_quad_mode(struct spi_nor *nor, u32 jedec_id)
++static int set_quad_mode(struct spi_nor *nor, const struct flash_info *info)
+ {
+ 	int status;
+ 
+-	switch (JEDEC_MFR(jedec_id)) {
+-	case CFI_MFR_MACRONIX:
++	switch (JEDEC_MFR(info)) {
++	case SNOR_MFR_MACRONIX:
+ 		status = macronix_quad_enable(nor);
+ 		if (status) {
+ 			dev_err(nor->dev, "Macronix quad-read not enabled\n");
+ 			return -EINVAL;
+ 		}
+ 		return status;
++	case SNOR_MFR_MICRON:
++		return 0;
+ 	default:
+ 		status = spansion_quad_enable(nor);
+ 		if (status) {
+@@ -904,21 +1099,15 @@ static int spi_nor_check(struct spi_nor
+ 		return -EINVAL;
+ 	}
+ 
+-	if (!nor->read_id)
+-		nor->read_id = spi_nor_read_id;
+-	if (!nor->wait_till_ready)
+-		nor->wait_till_ready = spi_nor_wait_till_ready;
+-
+ 	return 0;
+ }
+ 
+ int spi_nor_scan(struct spi_nor *nor, const char *name, enum read_mode mode)
+ {
+-	const struct spi_device_id	*id = NULL;
+-	struct flash_info		*info;
++	const struct flash_info *info = NULL;
+ 	struct device *dev = nor->dev;
+-	struct mtd_info *mtd = nor->mtd;
+-	struct device_node *np = dev->of_node;
++	struct mtd_info *mtd = &nor->mtd;
++	struct device_node *np = nor->flash_node;
+ 	int ret;
+ 	int i;
+ 
+@@ -926,19 +1115,25 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 	if (ret)
+ 		return ret;
+ 
+-	id = spi_nor_match_id(name);
+-	if (!id)
++	if (name)
++		info = spi_nor_match_id(name);
++	/* Try to auto-detect if chip name wasn't specified or not found */
++	if (!info)
++		info = spi_nor_read_id(nor);
++	if (IS_ERR_OR_NULL(info))
+ 		return -ENOENT;
+ 
+-	info = (void *)id->driver_data;
+-
+-	if (info->jedec_id) {
+-		const struct spi_device_id *jid;
++	/*
++	 * If caller has specified name of flash model that can normally be
++	 * detected using JEDEC, let's verify it.
++	 */
++	if (name && info->id_len) {
++		const struct flash_info *jinfo;
+ 
+-		jid = nor->read_id(nor);
+-		if (IS_ERR(jid)) {
+-			return PTR_ERR(jid);
+-		} else if (jid != id) {
++		jinfo = spi_nor_read_id(nor);
++		if (IS_ERR(jinfo)) {
++			return PTR_ERR(jinfo);
++		} else if (jinfo != info) {
+ 			/*
+ 			 * JEDEC knows better, so overwrite platform ID. We
+ 			 * can't trust partitions any longer, but we'll let
+@@ -947,28 +1142,28 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 			 * information, even if it's not 100% accurate.
+ 			 */
+ 			dev_warn(dev, "found %s, expected %s\n",
+-				 jid->name, id->name);
+-			id = jid;
+-			info = (void *)jid->driver_data;
++				 jinfo->name, info->name);
++			info = jinfo;
+ 		}
+ 	}
+ 
+ 	mutex_init(&nor->lock);
+ 
+ 	/*
+-	 * Atmel, SST and Intel/Numonyx serial nor tend to power
+-	 * up with the software protection bits set
++	 * Atmel, SST, Intel/Numonyx, and others serial NOR tend to power up
++	 * with the software protection bits set
+ 	 */
+ 
+-	if (JEDEC_MFR(info->jedec_id) == CFI_MFR_ATMEL ||
+-	    JEDEC_MFR(info->jedec_id) == CFI_MFR_INTEL ||
+-	    JEDEC_MFR(info->jedec_id) == CFI_MFR_SST) {
++	if (JEDEC_MFR(info) == SNOR_MFR_ATMEL ||
++	    JEDEC_MFR(info) == SNOR_MFR_INTEL ||
++	    JEDEC_MFR(info) == SNOR_MFR_SST) {
+ 		write_enable(nor);
+ 		write_sr(nor, 0);
+ 	}
+ 
+ 	if (!mtd->name)
+ 		mtd->name = dev_name(dev);
++	mtd->priv = nor;
+ 	mtd->type = MTD_NORFLASH;
+ 	mtd->writesize = 1;
+ 	mtd->flags = MTD_CAP_NORFLASH;
+@@ -976,10 +1171,17 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 	mtd->_erase = spi_nor_erase;
+ 	mtd->_read = spi_nor_read;
+ 
+-	/* nor protection support for STmicro chips */
+-	if (JEDEC_MFR(info->jedec_id) == CFI_MFR_ST) {
++	/* NOR protection support for STmicro/Micron chips and similar */
++	if (JEDEC_MFR(info) == SNOR_MFR_MICRON) {
++		nor->flash_lock = stm_lock;
++		nor->flash_unlock = stm_unlock;
++		nor->flash_is_locked = stm_is_locked;
++	}
++
++	if (nor->flash_lock && nor->flash_unlock && nor->flash_is_locked) {
+ 		mtd->_lock = spi_nor_lock;
+ 		mtd->_unlock = spi_nor_unlock;
++		mtd->_is_locked = spi_nor_is_locked;
+ 	}
+ 
+ 	/* sst nor chips use AAI word program */
+@@ -988,9 +1190,8 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 	else
+ 		mtd->_write = spi_nor_write;
+ 
+-	if ((info->flags & USE_FSR) &&
+-	    nor->wait_till_ready == spi_nor_wait_till_ready)
+-		nor->wait_till_ready = spi_nor_wait_till_fsr_ready;
++	if (info->flags & USE_FSR)
++		nor->flags |= SNOR_F_USE_FSR;
+ 
+ #ifdef CONFIG_MTD_SPI_NOR_USE_4K_SECTORS
+ 	/* prefer "small sector" erase if possible */
+@@ -1031,7 +1232,7 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 
+ 	/* Quad/Dual-read mode takes precedence over fast/normal */
+ 	if (mode == SPI_NOR_QUAD && info->flags & SPI_NOR_QUAD_READ) {
+-		ret = set_quad_mode(nor, info->jedec_id);
++		ret = set_quad_mode(nor, info);
+ 		if (ret) {
+ 			dev_err(dev, "quad mode not supported\n");
+ 			return ret;
+@@ -1067,7 +1268,7 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 	else if (mtd->size > 0x1000000) {
+ 		/* enable 4-byte addressing if the device exceeds 16MiB */
+ 		nor->addr_width = 4;
+-		if (JEDEC_MFR(info->jedec_id) == CFI_MFR_AMD) {
++		if (JEDEC_MFR(info) == SNOR_MFR_SPANSION) {
+ 			/* Dedicated 4-byte command set */
+ 			switch (nor->flash_read) {
+ 			case SPI_NOR_QUAD:
+@@ -1088,14 +1289,14 @@ int spi_nor_scan(struct spi_nor *nor, co
+ 			nor->erase_opcode = SPINOR_OP_SE_4B;
+ 			mtd->erasesize = info->sector_size;
+ 		} else
+-			set_4byte(nor, info->jedec_id, 1);
++			set_4byte(nor, info, 1);
+ 	} else {
+ 		nor->addr_width = 3;
+ 	}
+ 
+ 	nor->read_dummy = spi_nor_read_dummy_cycles(nor);
+ 
+-	dev_info(dev, "%s (%lld Kbytes)\n", id->name,
++	dev_info(dev, "%s (%lld Kbytes)\n", info->name,
+ 			(long long)mtd->size >> 10);
+ 
+ 	dev_dbg(dev,
+@@ -1118,11 +1319,11 @@ int spi_nor_scan(struct spi_nor *nor, co
+ }
+ EXPORT_SYMBOL_GPL(spi_nor_scan);
+ 
+-static const struct spi_device_id *spi_nor_match_id(const char *name)
++static const struct flash_info *spi_nor_match_id(const char *name)
+ {
+-	const struct spi_device_id *id = spi_nor_ids;
++	const struct flash_info *id = spi_nor_ids;
+ 
+-	while (id->name[0]) {
++	while (id->name) {
+ 		if (!strcmp(name, id->name))
+ 			return id;
+ 		id++;
+--- a/include/linux/mtd/spi-nor.h
++++ b/include/linux/mtd/spi-nor.h
+@@ -10,6 +10,23 @@
+ #ifndef __LINUX_MTD_SPI_NOR_H
+ #define __LINUX_MTD_SPI_NOR_H
+ 
++#include <linux/bitops.h>
++#include <linux/mtd/cfi.h>
++
++/*
++ * Manufacturer IDs
++ *
++ * The first byte returned from the flash after sending opcode SPINOR_OP_RDID.
++ * Sometimes these are the same as CFI IDs, but sometimes they aren't.
++ */
++#define SNOR_MFR_ATMEL		CFI_MFR_ATMEL
++#define SNOR_MFR_INTEL		CFI_MFR_INTEL
++#define SNOR_MFR_MICRON		CFI_MFR_ST /* ST Micro <--> Micron */
++#define SNOR_MFR_MACRONIX	CFI_MFR_MACRONIX
++#define SNOR_MFR_SPANSION	CFI_MFR_AMD
++#define SNOR_MFR_SST		CFI_MFR_SST
++#define SNOR_MFR_WINBOND	0xef /* Also used by some Spansion */
++
+ /*
+  * Note on opcode nomenclature: some opcodes have a format like
+  * SPINOR_OP_FUNCTION{4,}_x_y_z. The numbers x, y, and z stand for the number
+@@ -56,22 +73,29 @@
+ /* Used for Spansion flashes only. */
+ #define SPINOR_OP_BRWR		0x17	/* Bank register write */
+ 
++/* Used for Micron flashes only. */
++#define SPINOR_OP_RD_EVCR      0x65    /* Read EVCR register */
++#define SPINOR_OP_WD_EVCR      0x61    /* Write EVCR register */
++
+ /* Status Register bits. */
+-#define SR_WIP			1	/* Write in progress */
+-#define SR_WEL			2	/* Write enable latch */
++#define SR_WIP			BIT(0)	/* Write in progress */
++#define SR_WEL			BIT(1)	/* Write enable latch */
+ /* meaning of other SR_* bits may differ between vendors */
+-#define SR_BP0			4	/* Block protect 0 */
+-#define SR_BP1			8	/* Block protect 1 */
+-#define SR_BP2			0x10	/* Block protect 2 */
+-#define SR_SRWD			0x80	/* SR write protect */
++#define SR_BP0			BIT(2)	/* Block protect 0 */
++#define SR_BP1			BIT(3)	/* Block protect 1 */
++#define SR_BP2			BIT(4)	/* Block protect 2 */
++#define SR_SRWD			BIT(7)	/* SR write protect */
++
++#define SR_QUAD_EN_MX		BIT(6)	/* Macronix Quad I/O */
+ 
+-#define SR_QUAD_EN_MX		0x40	/* Macronix Quad I/O */
++/* Enhanced Volatile Configuration Register bits */
++#define EVCR_QUAD_EN_MICRON	BIT(7)	/* Micron Quad I/O */
+ 
+ /* Flag Status Register bits */
+-#define FSR_READY		0x80
++#define FSR_READY		BIT(7)
+ 
+ /* Configuration Register bits. */
+-#define CR_QUAD_EN_SPAN		0x2	/* Spansion Quad I/O */
++#define CR_QUAD_EN_SPAN		BIT(1)	/* Spansion Quad I/O */
+ 
+ enum read_mode {
+ 	SPI_NOR_NORMAL = 0,
+@@ -80,33 +104,6 @@ enum read_mode {
+ 	SPI_NOR_QUAD,
+ };
+ 
+-/**
+- * struct spi_nor_xfer_cfg - Structure for defining a Serial Flash transfer
+- * @wren:		command for "Write Enable", or 0x00 for not required
+- * @cmd:		command for operation
+- * @cmd_pins:		number of pins to send @cmd (1, 2, 4)
+- * @addr:		address for operation
+- * @addr_pins:		number of pins to send @addr (1, 2, 4)
+- * @addr_width:		number of address bytes
+- *			(3,4, or 0 for address not required)
+- * @mode:		mode data
+- * @mode_pins:		number of pins to send @mode (1, 2, 4)
+- * @mode_cycles:	number of mode cycles (0 for mode not required)
+- * @dummy_cycles:	number of dummy cycles (0 for dummy not required)
+- */
+-struct spi_nor_xfer_cfg {
+-	u8		wren;
+-	u8		cmd;
+-	u8		cmd_pins;
+-	u32		addr;
+-	u8		addr_pins;
+-	u8		addr_width;
+-	u8		mode;
+-	u8		mode_pins;
+-	u8		mode_cycles;
+-	u8		dummy_cycles;
+-};
+-
+ #define SPI_NOR_MAX_CMD_SIZE	8
+ enum spi_nor_ops {
+ 	SPI_NOR_OPS_READ = 0,
+@@ -116,11 +113,18 @@ enum spi_nor_ops {
+ 	SPI_NOR_OPS_UNLOCK,
+ };
+ 
++enum spi_nor_option_flags {
++	SNOR_F_USE_FSR		= BIT(0),
++};
++
++struct mtd_info;
++
+ /**
+  * struct spi_nor - Structure for defining a the SPI NOR layer
+  * @mtd:		point to a mtd_info structure
+  * @lock:		the lock for the read/write/erase/lock/unlock operations
+  * @dev:		point to a spi device, or a spi nor controller device.
++ * @flash_node:		point to a device node describing this flash instance.
+  * @page_size:		the page size of the SPI NOR
+  * @addr_width:		number of address bytes
+  * @erase_opcode:	the opcode for erasing a sector
+@@ -129,29 +133,29 @@ enum spi_nor_ops {
+  * @program_opcode:	the program opcode
+  * @flash_read:		the mode of the read
+  * @sst_write_second:	used by the SST write operation
+- * @cfg:		used by the read_xfer/write_xfer
++ * @flags:		flag options for the current SPI-NOR (SNOR_F_*)
+  * @cmd_buf:		used by the write_reg
+  * @prepare:		[OPTIONAL] do some preparations for the
+  *			read/write/erase/lock/unlock operations
+  * @unprepare:		[OPTIONAL] do some post work after the
+  *			read/write/erase/lock/unlock operations
+- * @read_xfer:		[OPTIONAL] the read fundamental primitive
+- * @write_xfer:		[OPTIONAL] the writefundamental primitive
+  * @read_reg:		[DRIVER-SPECIFIC] read out the register
+  * @write_reg:		[DRIVER-SPECIFIC] write data to the register
+- * @read_id:		[REPLACEABLE] read out the ID data, and find
+- *			the proper spi_device_id
+- * @wait_till_ready:	[REPLACEABLE] wait till the NOR becomes ready
+  * @read:		[DRIVER-SPECIFIC] read data from the SPI NOR
+  * @write:		[DRIVER-SPECIFIC] write data to the SPI NOR
+  * @erase:		[DRIVER-SPECIFIC] erase a sector of the SPI NOR
+  *			at the offset @offs
++ * @flash_lock:		[FLASH-SPECIFIC] lock a region of the SPI NOR
++ * @flash_unlock:	[FLASH-SPECIFIC] unlock a region of the SPI NOR
++ * @flash_is_locked:	[FLASH-SPECIFIC] check if a region of the SPI NOR is
++ *			completely locked
+  * @priv:		the private data
+  */
+ struct spi_nor {
+-	struct mtd_info		*mtd;
++	struct mtd_info		mtd;
+ 	struct mutex		lock;
+ 	struct device		*dev;
++	struct device_node	*flash_node;
+ 	u32			page_size;
+ 	u8			addr_width;
+ 	u8			erase_opcode;
+@@ -160,20 +164,13 @@ struct spi_nor {
+ 	u8			program_opcode;
+ 	enum read_mode		flash_read;
+ 	bool			sst_write_second;
+-	struct spi_nor_xfer_cfg	cfg;
++	u32			flags;
+ 	u8			cmd_buf[SPI_NOR_MAX_CMD_SIZE];
+ 
+ 	int (*prepare)(struct spi_nor *nor, enum spi_nor_ops ops);
+ 	void (*unprepare)(struct spi_nor *nor, enum spi_nor_ops ops);
+-	int (*read_xfer)(struct spi_nor *nor, struct spi_nor_xfer_cfg *cfg,
+-			 u8 *buf, size_t len);
+-	int (*write_xfer)(struct spi_nor *nor, struct spi_nor_xfer_cfg *cfg,
+-			  u8 *buf, size_t len);
+ 	int (*read_reg)(struct spi_nor *nor, u8 opcode, u8 *buf, int len);
+-	int (*write_reg)(struct spi_nor *nor, u8 opcode, u8 *buf, int len,
+-			int write_enable);
+-	const struct spi_device_id *(*read_id)(struct spi_nor *nor);
+-	int (*wait_till_ready)(struct spi_nor *nor);
++	int (*write_reg)(struct spi_nor *nor, u8 opcode, u8 *buf, int len);
+ 
+ 	int (*read)(struct spi_nor *nor, loff_t from,
+ 			size_t len, size_t *retlen, u_char *read_buf);
+@@ -181,6 +178,10 @@ struct spi_nor {
+ 			size_t len, size_t *retlen, const u_char *write_buf);
+ 	int (*erase)(struct spi_nor *nor, loff_t offs);
+ 
++	int (*flash_lock)(struct spi_nor *nor, loff_t ofs, uint64_t len);
++	int (*flash_unlock)(struct spi_nor *nor, loff_t ofs, uint64_t len);
++	int (*flash_is_locked)(struct spi_nor *nor, loff_t ofs, uint64_t len);
++
+ 	void *priv;
+ };
+ 
diff --git a/target/linux/generic/patches-3.18/462-m25p80-mx-disable-software-protection.patch b/target/linux/generic/patches-3.18/462-m25p80-mx-disable-software-protection.patch
index fef483a..eb99609 100644
--- a/target/linux/generic/patches-3.18/462-m25p80-mx-disable-software-protection.patch
+++ b/target/linux/generic/patches-3.18/462-m25p80-mx-disable-software-protection.patch
@@ -1,10 +1,14 @@
+Disable software protection bits for Macronix flashes.
+
+Signed-off-by: Felix Fietkau <nbd@openwrt.org>
+
 --- a/drivers/mtd/spi-nor/spi-nor.c
 +++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -963,6 +963,7 @@ int spi_nor_scan(struct spi_nor *nor, co
+@@ -1164,6 +1164,7 @@ int spi_nor_scan(struct spi_nor *nor, co
  
- 	if (JEDEC_MFR(info->jedec_id) == CFI_MFR_ATMEL ||
- 	    JEDEC_MFR(info->jedec_id) == CFI_MFR_INTEL ||
-+	    JEDEC_MFR(info->jedec_id) == CFI_MFR_MACRONIX ||
- 	    JEDEC_MFR(info->jedec_id) == CFI_MFR_SST) {
+ 	if (JEDEC_MFR(info) == SNOR_MFR_ATMEL ||
+ 	    JEDEC_MFR(info) == SNOR_MFR_INTEL ||
++	    JEDEC_MFR(info) == SNOR_MFR_MACRONIX ||
+ 	    JEDEC_MFR(info) == SNOR_MFR_SST) {
  		write_enable(nor);
  		write_sr(nor, 0);
diff --git a/target/linux/generic/patches-3.18/472-mtd-m25p80-add-support-for-Winbond-W25X05-flash.patch b/target/linux/generic/patches-3.18/472-mtd-m25p80-add-support-for-Winbond-W25X05-flash.patch
deleted file mode 100644
index dca6895..0000000
--- a/target/linux/generic/patches-3.18/472-mtd-m25p80-add-support-for-Winbond-W25X05-flash.patch
+++ /dev/null
@@ -1,20 +0,0 @@
-From eef9dfc4e821408af1af13aa0cc707fc496fb7c6 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Wed, 11 Dec 2013 19:05:59 +0100
-Subject: [PATCH] m25p80: add support for the Winbond W25X05 flash
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/devices/m25p80.c |    1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -617,6 +617,7 @@ static const struct spi_device_id spi_no
- 	{ "m25px80",    INFO(0x207114,  0, 64 * 1024, 16, 0) },
- 
- 	/* Winbond -- w25x "blocks" are 64K, "sectors" are 4KiB */
-+	{ "w25x05", INFO(0xef3010, 0, 64 * 1024,  1,  SECT_4K) },
- 	{ "w25x10", INFO(0xef3011, 0, 64 * 1024,  2,  SECT_4K) },
- 	{ "w25x20", INFO(0xef3012, 0, 64 * 1024,  4,  SECT_4K) },
- 	{ "w25x40", INFO(0xef3013, 0, 64 * 1024,  8,  SECT_4K) },
diff --git a/target/linux/generic/patches-3.18/473-mtd-spi-nor-add-support-for-the-Macronix-MX25L512E-S.patch b/target/linux/generic/patches-3.18/473-mtd-spi-nor-add-support-for-the-Macronix-MX25L512E-S.patch
deleted file mode 100644
index 9ba7a4a..0000000
--- a/target/linux/generic/patches-3.18/473-mtd-spi-nor-add-support-for-the-Macronix-MX25L512E-S.patch
+++ /dev/null
@@ -1,21 +0,0 @@
-From 0d7388de0911c1a4fc4a8a3898ef9d0ab818ca08 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Tue, 7 Apr 2015 18:35:15 +0200
-Subject: [PATCH] mtd: spi-nor: add support for the Macronix MX25L512E SPI
- flash chip
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/spi-nor/spi-nor.c |    1 +
- 1 file changed, 1 insertion(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -518,6 +518,7 @@ static const struct spi_device_id spi_no
- 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
- 
- 	/* Macronix */
-+	{ "mx25l512e",   INFO(0xc22010, 0, 64 * 1024,   1, SECT_4K) },
- 	{ "mx25l2005a",  INFO(0xc22012, 0, 64 * 1024,   4, SECT_4K) },
- 	{ "mx25l4005a",  INFO(0xc22013, 0, 64 * 1024,   8, SECT_4K) },
- 	{ "mx25l8005",   INFO(0xc22014, 0, 64 * 1024,  16, 0) },
diff --git a/target/linux/generic/patches-3.18/474-mtd-spi-nor-add-support-for-the-ISSI-SI25CD512-SPI-f.patch b/target/linux/generic/patches-3.18/474-mtd-spi-nor-add-support-for-the-ISSI-SI25CD512-SPI-f.patch
deleted file mode 100644
index b06ac73..0000000
--- a/target/linux/generic/patches-3.18/474-mtd-spi-nor-add-support-for-the-ISSI-SI25CD512-SPI-f.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-From 34e2b403040a2f9d3ba071d95a7f42457e2950f9 Mon Sep 17 00:00:00 2001
-From: Gabor Juhos <juhosg@openwrt.org>
-Date: Tue, 7 Apr 2015 18:35:15 +0200
-Subject: [PATCH] mtd: spi-nor: add support for the ISSI SI25CD512 SPI flash
-
-Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
----
- drivers/mtd/spi-nor/spi-nor.c |    3 +++
- 1 file changed, 3 insertions(+)
-
---- a/drivers/mtd/spi-nor/spi-nor.c
-+++ b/drivers/mtd/spi-nor/spi-nor.c
-@@ -517,6 +517,9 @@ static const struct spi_device_id spi_no
- 	{ "320s33b",  INFO(0x898912, 0, 64 * 1024,  64, 0) },
- 	{ "640s33b",  INFO(0x898913, 0, 64 * 1024, 128, 0) },
- 
-+	/* ISSI */
-+	{ "is25cd512", INFO(0x7f9d20, 0, 32 * 1024,   2, SECT_4K) },
-+
- 	/* Macronix */
- 	{ "mx25l512e",   INFO(0xc22010, 0, 64 * 1024,   1, SECT_4K) },
- 	{ "mx25l2005a",  INFO(0xc22012, 0, 64 * 1024,   4, SECT_4K) },
diff --git a/target/linux/lantiq/patches-3.18/0022-MTD-m25p80-allow-loading-mtd-name-from-OF.patch b/target/linux/lantiq/patches-3.18/0022-MTD-m25p80-allow-loading-mtd-name-from-OF.patch
deleted file mode 100644
index 203eb94..0000000
--- a/target/linux/lantiq/patches-3.18/0022-MTD-m25p80-allow-loading-mtd-name-from-OF.patch
+++ /dev/null
@@ -1,44 +0,0 @@
-From 4400e1f593ea40a51912128adb4f53d59e62cad8 Mon Sep 17 00:00:00 2001
-From: John Crispin <blogic@openwrt.org>
-Date: Wed, 10 Sep 2014 22:40:18 +0200
-Subject: [PATCH 22/36] MTD: m25p80: allow loading mtd name from OF
-
-In accordance with the physmap flash we should honour the linux,mtd-name
-property when deciding what name the mtd device has.
-
-Signed-off-by: Thomas Langer <thomas.langer@lantiq.com>
-Signed-off-by: John Crispin <blogic@openwrt.org>
----
- drivers/mtd/devices/m25p80.c |    6 ++++++
- 1 file changed, 6 insertions(+)
-
---- a/drivers/mtd/devices/m25p80.c
-+++ b/drivers/mtd/devices/m25p80.c
-@@ -19,6 +19,7 @@
- #include <linux/errno.h>
- #include <linux/module.h>
- #include <linux/device.h>
-+#include <linux/of.h>
- 
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-@@ -198,6 +199,10 @@ static int m25p_probe(struct spi_device
- 	enum read_mode mode = SPI_NOR_NORMAL;
- 	char *flash_name = NULL;
- 	int ret;
-+	const char __maybe_unused	*of_mtd_name = NULL;
-+
-+	of_property_read_string(spi->dev.of_node,
-+		"linux,mtd-name", &of_mtd_name);
- 
- 	data = dev_get_platdata(&spi->dev);
- 
-@@ -229,6 +234,8 @@ static int m25p_probe(struct spi_device
- 
- 	if (data && data->name)
- 		flash->mtd.name = data->name;
-+	else if (of_mtd_name)
-+		flash->mtd.name = of_mtd_name;
- 
- 	/* For some (historical?) reason many platforms provide two different
- 	 * names in flash_platform_data: "name" and "type". Quite often name is
diff --git a/target/linux/mpc85xx/files/arch/powerpc/boot/dts/tl-wdr4900-v1.dts b/target/linux/mpc85xx/files/arch/powerpc/boot/dts/tl-wdr4900-v1.dts
index 2beb39c..21f823d 100644
--- a/target/linux/mpc85xx/files/arch/powerpc/boot/dts/tl-wdr4900-v1.dts
+++ b/target/linux/mpc85xx/files/arch/powerpc/boot/dts/tl-wdr4900-v1.dts
@@ -37,7 +37,7 @@
 			flash@0 {
 				#address-cells = <1>;
 				#size-cells = <1>;
-				compatible = "spansion,s25fl129p1";
+				compatible = "jedec,spi-nor";
 				reg = <0>;
 				spi-max-frequency = <25000000>;
 
diff --git a/target/linux/ramips/patches-3.18/0044-mtd-add-chunked-read-io-to-m25p80.patch b/target/linux/ramips/patches-3.18/0044-mtd-add-chunked-read-io-to-m25p80.patch
deleted file mode 100644
index 1716e1c..0000000
--- a/target/linux/ramips/patches-3.18/0044-mtd-add-chunked-read-io-to-m25p80.patch
+++ /dev/null
@@ -1,103 +0,0 @@
---- a/drivers/mtd/devices/m25p80.c
-+++ b/drivers/mtd/devices/m25p80.c
-@@ -19,6 +19,7 @@
- #include <linux/errno.h>
- #include <linux/module.h>
- #include <linux/device.h>
-+#include <linux/of.h>
- 
- #include <linux/mtd/mtd.h>
- #include <linux/mtd/partitions.h>
-@@ -32,6 +33,7 @@ struct m25p {
- 	struct spi_device	*spi;
- 	struct spi_nor		spi_nor;
- 	struct mtd_info		mtd;
-+	u16			chunk_size;
- 	u8			command[MAX_CMD_SIZE];
- };
- 
-@@ -157,6 +159,61 @@ static int m25p80_read(struct spi_nor *n
- 	return 0;
- }
- 
-+static void m25p80_chunked_write(struct spi_nor *nor, loff_t _from, size_t _len,
-+			size_t *_retlen, const u_char *_buf)
-+{
-+	struct m25p *flash = nor->priv;
-+	int chunk_size;
-+	int retlen = 0;
-+
-+	chunk_size = flash->chunk_size;
-+	if (!chunk_size)
-+		chunk_size = _len;
-+
-+	if (nor->addr_width > 3)
-+		chunk_size -= nor->addr_width - 3;
-+
-+	while (retlen < _len) {
-+		size_t len = min_t(int, chunk_size, _len - retlen);
-+		const u_char *buf = _buf + retlen;
-+		loff_t from = _from + retlen;
-+
-+		nor->wait_till_ready(nor);
-+		nor->write_reg(nor, SPINOR_OP_WREN, NULL, 0, 0);
-+
-+		m25p80_write(nor, from, len, &retlen, buf);
-+	}
-+	*_retlen += retlen;
-+}
-+
-+static int m25p80_chunked_read(struct spi_nor *nor, loff_t _from, size_t _len,
-+			size_t *_retlen, u_char *_buf)
-+{
-+	struct m25p *flash = nor->priv;
-+	int chunk_size;
-+
-+	chunk_size = flash->chunk_size;
-+	if (!chunk_size)
-+		chunk_size = _len;
-+
-+	*_retlen = 0;
-+
-+	while (*_retlen < _len) {
-+		size_t len = min_t(int, chunk_size, _len - *_retlen);
-+		u_char *buf = _buf + *_retlen;
-+		loff_t from = _from + *_retlen;
-+		int retlen = 0;
-+		int ret = m25p80_read(nor, from, len, &retlen, buf);
-+
-+		if (ret)
-+			return ret;
-+
-+		*_retlen += retlen;
-+	}
-+
-+	return 0;
-+}
-+
- static int m25p80_erase(struct spi_nor *nor, loff_t offset)
- {
- 	struct m25p *flash = nor->priv;
-@@ -197,6 +254,7 @@ static int m25p_probe(struct spi_device
- 	struct spi_nor *nor;
- 	enum read_mode mode = SPI_NOR_NORMAL;
- 	char *flash_name = NULL;
-+	u32 val;
- 	int ret;
- 
- 	data = dev_get_platdata(&spi->dev);
-@@ -244,6 +302,14 @@ static int m25p_probe(struct spi_device
- 	if (ret)
- 		return ret;
- 
-+	if (spi->dev.of_node &&
-+	    !of_property_read_u32(spi->dev.of_node, "m25p,chunked-io", &val)) {
-+		dev_warn(&spi->dev, "using chunked io\n");
-+		nor->read = m25p80_chunked_read;
-+		nor->write = m25p80_chunked_write;
-+		flash->chunk_size = val;
-+	}
-+
- 	ppdata.of_node = spi->dev.of_node;
- 
- 	return mtd_device_parse_register(&flash->mtd, NULL, &ppdata,
