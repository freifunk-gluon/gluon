From: Benedikt Neuffer <github@itfriend.de>
Date: Mon, 28 Sep 2015 10:05:57 +0200
Subject: ar8216: support tagged an untagged ports

based on https://dev.openwrt.org/changeset/42653

diff --git a/target/linux/generic/files/drivers/net/phy/ar8216.c b/target/linux/generic/files/drivers/net/phy/ar8216.c
index e39d540..bd6cc97 100644
--- a/target/linux/generic/files/drivers/net/phy/ar8216.c
+++ b/target/linux/generic/files/drivers/net/phy/ar8216.c
@@ -33,15 +33,141 @@
 #include <linux/lockdep.h>
 #include <linux/ar8216_platform.h>
 #include <linux/workqueue.h>
-#include <linux/version.h>
+#include <linux/of_device.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
 
 #include "ar8216.h"
 
-extern const struct ar8xxx_chip ar8327_chip;
-extern const struct ar8xxx_chip ar8337_chip;
+/* size of the vlan table */
+#define AR8X16_MAX_VLANS	128
+#define AR8X16_PROBE_RETRIES	10
+#define AR8X16_MAX_PORTS	8
 
 #define AR8XXX_MIB_WORK_DELAY	2000 /* msecs */
 
+struct ar8xxx_priv;
+
+#define AR8XXX_CAP_GIGE			BIT(0)
+#define AR8XXX_CAP_MIB_COUNTERS		BIT(1)
+
+enum {
+	AR8XXX_VER_AR8216 = 0x01,
+	AR8XXX_VER_AR8236 = 0x03,
+	AR8XXX_VER_AR8316 = 0x10,
+	AR8XXX_VER_AR8327 = 0x12,
+	AR8XXX_VER_AR8337 = 0x13,
+};
+
+struct ar8xxx_mib_desc {
+	unsigned int size;
+	unsigned int offset;
+	const char *name;
+};
+
+struct ar8xxx_chip {
+	unsigned long caps;
+
+	int (*hw_init)(struct ar8xxx_priv *priv);
+	void (*cleanup)(struct ar8xxx_priv *priv);
+
+	void (*init_globals)(struct ar8xxx_priv *priv);
+	void (*init_port)(struct ar8xxx_priv *priv, int port);
+	void (*setup_port)(struct ar8xxx_priv *priv, int port, u32 members);
+	u32 (*read_port_status)(struct ar8xxx_priv *priv, int port);
+	int (*atu_flush)(struct ar8xxx_priv *priv);
+	void (*vtu_flush)(struct ar8xxx_priv *priv);
+	void (*vtu_load_vlan)(struct ar8xxx_priv *priv, u32 vid, u32 port_mask);
+
+	const struct ar8xxx_mib_desc *mib_decs;
+	unsigned num_mibs;
+};
+
+enum ar8327_led_pattern {
+	AR8327_LED_PATTERN_OFF = 0,
+	AR8327_LED_PATTERN_BLINK,
+	AR8327_LED_PATTERN_ON,
+	AR8327_LED_PATTERN_RULE,
+};
+
+struct ar8327_led_entry {
+	unsigned reg;
+	unsigned shift;
+};
+
+struct ar8327_led {
+	struct led_classdev cdev;
+	struct ar8xxx_priv *sw_priv;
+
+	char *name;
+	bool active_low;
+	u8 led_num;
+	enum ar8327_led_mode mode;
+
+	struct mutex mutex;
+	spinlock_t lock;
+	struct work_struct led_work;
+	bool enable_hw_mode;
+	enum ar8327_led_pattern pattern;
+};
+
+struct ar8327_data {
+	u32 port0_status;
+	u32 port6_status;
+
+	struct ar8327_led **leds;
+	unsigned int num_leds;
+};
+
+struct ar8xxx_priv {
+	struct switch_dev dev;
+	struct mii_bus *mii_bus;
+	struct phy_device *phy;
+
+	u32 (*read)(struct ar8xxx_priv *priv, int reg);
+	void (*write)(struct ar8xxx_priv *priv, int reg, u32 val);
+	u32 (*rmw)(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val);
+
+	int (*get_port_link)(unsigned port);
+
+	const struct net_device_ops *ndo_old;
+	struct net_device_ops ndo;
+	struct mutex reg_mutex;
+	u8 chip_ver;
+	u8 chip_rev;
+	const struct ar8xxx_chip *chip;
+	union {
+		struct ar8327_data ar8327;
+	} chip_data;
+	bool initialized;
+	bool port4_phy;
+	char buf[2048];
+
+	bool init;
+	bool mii_lo_first;
+
+	struct mutex mib_lock;
+	struct delayed_work mib_work;
+	int mib_next_port;
+	u64 *mib_stats;
+
+	struct list_head list;
+	unsigned int use_count;
+
+	/* all fields below are cleared on reset */
+	bool vlan;
+	u16 vlan_id[AR8X16_MAX_VLANS];
+	u8 vlan_table[AR8X16_MAX_VLANS];
+	u8 vlan_tagged;
+	u16 pvid[AR8X16_MAX_PORTS];
+
+	/* mirroring */
+	bool mirror_rx;
+	bool mirror_tx;
+	int source_port;
+	int monitor_port;
+};
+
 #define MIB_DESC(_s , _o, _n)	\
 	{			\
 		.size = (_s),	\
@@ -89,7 +215,7 @@ static const struct ar8xxx_mib_desc ar8216_mibs[] = {
 	MIB_DESC(1, AR8216_STATS_TXLATECOL, "TxLateCol"),
 };
 
-const struct ar8xxx_mib_desc ar8236_mibs[39] = {
+static const struct ar8xxx_mib_desc ar8236_mibs[] = {
 	MIB_DESC(1, AR8236_STATS_RXBROAD, "RxBroad"),
 	MIB_DESC(1, AR8236_STATS_RXPAUSE, "RxPause"),
 	MIB_DESC(1, AR8236_STATS_RXMULTI, "RxMulti"),
@@ -134,149 +260,113 @@ const struct ar8xxx_mib_desc ar8236_mibs[39] = {
 static DEFINE_MUTEX(ar8xxx_dev_list_lock);
 static LIST_HEAD(ar8xxx_dev_list);
 
-/* inspired by phy_poll_reset in drivers/net/phy/phy_device.c */
-static int
-ar8xxx_phy_poll_reset(struct mii_bus *bus)
-{
-        unsigned int sleep_msecs = 20;
-        int ret, elapsed, i;
-
-        for (elapsed = sleep_msecs; elapsed <= 600;
-	     elapsed += sleep_msecs) {
-                msleep(sleep_msecs);
-                for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
-                        ret = mdiobus_read(bus, i, MII_BMCR);
-                        if (ret < 0)
-				return ret;
-                        if (ret & BMCR_RESET)
-				break;
-                        if (i == AR8XXX_NUM_PHYS - 1) {
-                                usleep_range(1000, 2000);
-                                return 0;
-                        }
-                }
-        }
-        return -ETIMEDOUT;
+static inline struct ar8xxx_priv *
+swdev_to_ar8xxx(struct switch_dev *swdev)
+{
+	return container_of(swdev, struct ar8xxx_priv, dev);
 }
 
-static int
-ar8xxx_phy_check_aneg(struct phy_device *phydev)
+static inline bool ar8xxx_has_gige(struct ar8xxx_priv *priv)
 {
-	int ret;
-
-	if (phydev->autoneg != AUTONEG_ENABLE)
-		return 0;
-	/*
-	 * BMCR_ANENABLE might have been cleared
-	 * by phy_init_hw in certain kernel versions
-	 * therefore check for it
-	 */
-	ret = phy_read(phydev, MII_BMCR);
-	if (ret < 0)
-		return ret;
-	if (ret & BMCR_ANENABLE)
-		return 0;
-
-	dev_info(&phydev->dev, "ANEG disabled, re-enabling ...\n");
-	ret |= BMCR_ANENABLE | BMCR_ANRESTART;
-	return phy_write(phydev, MII_BMCR, ret);
+	return priv->chip->caps & AR8XXX_CAP_GIGE;
 }
 
-void
-ar8xxx_phy_init(struct ar8xxx_priv *priv)
+static inline bool ar8xxx_has_mib_counters(struct ar8xxx_priv *priv)
 {
-	int i;
-	struct mii_bus *bus;
-
-	bus = priv->mii_bus;
-	for (i = 0; i < AR8XXX_NUM_PHYS; i++) {
-		if (priv->chip->phy_fixup)
-			priv->chip->phy_fixup(priv, i);
+	return priv->chip->caps & AR8XXX_CAP_MIB_COUNTERS;
+}
 
-		/* initialize the port itself */
-		mdiobus_write(bus, i, MII_ADVERTISE,
-			ADVERTISE_ALL | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
-		if (ar8xxx_has_gige(priv))
-			mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
-		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
-	}
+static inline bool chip_is_ar8216(struct ar8xxx_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8216;
+}
 
-	ar8xxx_phy_poll_reset(bus);
+static inline bool chip_is_ar8236(struct ar8xxx_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8236;
 }
 
-u32
-ar8xxx_mii_read32(struct ar8xxx_priv *priv, int phy_id, int regnum)
+static inline bool chip_is_ar8316(struct ar8xxx_priv *priv)
 {
-	struct mii_bus *bus = priv->mii_bus;
-	u16 lo, hi;
+	return priv->chip_ver == AR8XXX_VER_AR8316;
+}
 
-	lo = bus->read(bus, phy_id, regnum);
-	hi = bus->read(bus, phy_id, regnum + 1);
+static inline bool chip_is_ar8327(struct ar8xxx_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8327;
+}
 
-	return (hi << 16) | lo;
+static inline bool chip_is_ar8337(struct ar8xxx_priv *priv)
+{
+	return priv->chip_ver == AR8XXX_VER_AR8337;
 }
 
-void
-ar8xxx_mii_write32(struct ar8xxx_priv *priv, int phy_id, int regnum, u32 val)
+static inline void
+split_addr(u32 regaddr, u16 *r1, u16 *r2, u16 *page)
 {
-	struct mii_bus *bus = priv->mii_bus;
-	u16 lo, hi;
+	regaddr >>= 1;
+	*r1 = regaddr & 0x1e;
 
-	lo = val & 0xffff;
-	hi = (u16) (val >> 16);
+	regaddr >>= 5;
+	*r2 = regaddr & 0x7;
 
-	if (priv->chip->mii_lo_first)
-	{
-		bus->write(bus, phy_id, regnum, lo);
-		bus->write(bus, phy_id, regnum + 1, hi);
-	} else {
-		bus->write(bus, phy_id, regnum + 1, hi);
-		bus->write(bus, phy_id, regnum, lo);
-	}
+	regaddr >>= 3;
+	*page = regaddr & 0x1ff;
 }
 
-u32
-ar8xxx_read(struct ar8xxx_priv *priv, int reg)
+static u32
+ar8xxx_mii_read(struct ar8xxx_priv *priv, int reg)
 {
 	struct mii_bus *bus = priv->mii_bus;
 	u16 r1, r2, page;
-	u32 val;
+	u16 lo, hi;
 
 	split_addr((u32) reg, &r1, &r2, &page);
 
 	mutex_lock(&bus->mdio_lock);
 
 	bus->write(bus, 0x18, 0, page);
-	wait_for_page_switch();
-	val = ar8xxx_mii_read32(priv, 0x10 | r2, r1);
+	usleep_range(1000, 2000); /* wait for the page switch to propagate */
+	lo = bus->read(bus, 0x10 | r2, r1);
+	hi = bus->read(bus, 0x10 | r2, r1 + 1);
 
 	mutex_unlock(&bus->mdio_lock);
 
-	return val;
+	return (hi << 16) | lo;
 }
 
-void
-ar8xxx_write(struct ar8xxx_priv *priv, int reg, u32 val)
+static void
+ar8xxx_mii_write(struct ar8xxx_priv *priv, int reg, u32 val)
 {
 	struct mii_bus *bus = priv->mii_bus;
-	u16 r1, r2, page;
+	u16 r1, r2, r3;
+	u16 lo, hi;
 
-	split_addr((u32) reg, &r1, &r2, &page);
+	split_addr((u32) reg, &r1, &r2, &r3);
+	lo = val & 0xffff;
+	hi = (u16) (val >> 16);
 
 	mutex_lock(&bus->mdio_lock);
 
-	bus->write(bus, 0x18, 0, page);
-	wait_for_page_switch();
-	ar8xxx_mii_write32(priv, 0x10 | r2, r1, val);
+	bus->write(bus, 0x18, 0, r3);
+	usleep_range(1000, 2000); /* wait for the page switch to propagate */
+	if (priv->mii_lo_first) {
+		bus->write(bus, 0x10 | r2, r1, lo);
+		bus->write(bus, 0x10 | r2, r1 + 1, hi);
+	} else {
+		bus->write(bus, 0x10 | r2, r1 + 1, hi);
+		bus->write(bus, 0x10 | r2, r1, lo);
+	}
 
 	mutex_unlock(&bus->mdio_lock);
 }
 
-u32
-ar8xxx_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
+static u32
+ar8xxx_mii_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
 {
 	struct mii_bus *bus = priv->mii_bus;
 	u16 r1, r2, page;
+	u16 lo, hi;
 	u32 ret;
 
 	split_addr((u32) reg, &r1, &r2, &page);
@@ -284,19 +374,33 @@ ar8xxx_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
 	mutex_lock(&bus->mdio_lock);
 
 	bus->write(bus, 0x18, 0, page);
-	wait_for_page_switch();
+	usleep_range(1000, 2000); /* wait for the page switch to propagate */
+
+	lo = bus->read(bus, 0x10 | r2, r1);
+	hi = bus->read(bus, 0x10 | r2, r1 + 1);
 
-	ret = ar8xxx_mii_read32(priv, 0x10 | r2, r1);
+	ret = hi << 16 | lo;
 	ret &= ~mask;
 	ret |= val;
-	ar8xxx_mii_write32(priv, 0x10 | r2, r1, ret);
+
+	lo = ret & 0xffff;
+	hi = (u16) (ret >> 16);
+
+	if (priv->mii_lo_first) {
+		bus->write(bus, 0x10 | r2, r1, lo);
+		bus->write(bus, 0x10 | r2, r1 + 1, hi);
+	} else {
+		bus->write(bus, 0x10 | r2, r1 + 1, hi);
+		bus->write(bus, 0x10 | r2, r1, lo);
+	}
 
 	mutex_unlock(&bus->mdio_lock);
 
 	return ret;
 }
 
-void
+
+static void
 ar8xxx_phy_dbg_write(struct ar8xxx_priv *priv, int phy_addr,
 		     u16 dbg_addr, u16 dbg_data)
 {
@@ -308,7 +412,7 @@ ar8xxx_phy_dbg_write(struct ar8xxx_priv *priv, int phy_addr,
 	mutex_unlock(&bus->mdio_lock);
 }
 
-void
+static void
 ar8xxx_phy_mmd_write(struct ar8xxx_priv *priv, int phy_addr, u16 addr, u16 data)
 {
 	struct mii_bus *bus = priv->mii_bus;
@@ -319,18 +423,16 @@ ar8xxx_phy_mmd_write(struct ar8xxx_priv *priv, int phy_addr, u16 addr, u16 data)
 	mutex_unlock(&bus->mdio_lock);
 }
 
-u16
-ar8xxx_phy_mmd_read(struct ar8xxx_priv *priv, int phy_addr, u16 addr)
+static inline u32
+ar8xxx_rmw(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
 {
-	struct mii_bus *bus = priv->mii_bus;
-	u16 data;
-
-	mutex_lock(&bus->mdio_lock);
-	bus->write(bus, phy_addr, MII_ATH_MMD_ADDR, addr);
-	data = bus->read(bus, phy_addr, MII_ATH_MMD_DATA);
-	mutex_unlock(&bus->mdio_lock);
+	return priv->rmw(priv, reg, mask, val);
+}
 
-	return data;
+static inline void
+ar8xxx_reg_set(struct ar8xxx_priv *priv, int reg, u32 val)
+{
+	priv->rmw(priv, reg, 0, val);
 }
 
 static int
@@ -342,7 +444,7 @@ ar8xxx_reg_wait(struct ar8xxx_priv *priv, u32 reg, u32 mask, u32 val,
 	for (i = 0; i < timeout; i++) {
 		u32 t;
 
-		t = ar8xxx_read(priv, reg);
+		t = priv->read(priv, reg);
 		if ((t & mask) == val)
 			return 0;
 
@@ -355,11 +457,16 @@ ar8xxx_reg_wait(struct ar8xxx_priv *priv, u32 reg, u32 mask, u32 val,
 static int
 ar8xxx_mib_op(struct ar8xxx_priv *priv, u32 op)
 {
-	unsigned mib_func = priv->chip->mib_func;
+	unsigned mib_func;
 	int ret;
 
 	lockdep_assert_held(&priv->mib_lock);
 
+	if (chip_is_ar8327(priv) || chip_is_ar8337(priv))
+		mib_func = AR8327_REG_MIB_FUNC;
+	else
+		mib_func = AR8216_REG_MIB_FUNC;
+
 	/* Capture the hardware statistics for all ports */
 	ar8xxx_rmw(priv, mib_func, AR8216_MIB_FUNC, (op << AR8216_MIB_FUNC_S));
 
@@ -397,8 +504,13 @@ ar8xxx_mib_fetch_port_stat(struct ar8xxx_priv *priv, int port, bool flush)
 
 	lockdep_assert_held(&priv->mib_lock);
 
-	base = priv->chip->reg_port_stats_start +
-	       priv->chip->reg_port_stats_length * port;
+	if (chip_is_ar8327(priv) || chip_is_ar8337(priv))
+		base = AR8327_REG_PORT_STATS_BASE(port);
+	else if (chip_is_ar8236(priv) ||
+		 chip_is_ar8316(priv))
+		base = AR8236_REG_PORT_STATS_BASE(port);
+	else
+		base = AR8216_REG_PORT_STATS_BASE(port);
 
 	mib_stats = &priv->mib_stats[port * priv->chip->num_mibs];
 	for (i = 0; i < priv->chip->num_mibs; i++) {
@@ -406,11 +518,11 @@ ar8xxx_mib_fetch_port_stat(struct ar8xxx_priv *priv, int port, bool flush)
 		u64 t;
 
 		mib = &priv->chip->mib_decs[i];
-		t = ar8xxx_read(priv, base + mib->offset);
+		t = priv->read(priv, base + mib->offset);
 		if (mib->size == 2) {
 			u64 hi;
 
-			hi = ar8xxx_read(priv, base + mib->offset + 4);
+			hi = priv->read(priv, base + mib->offset + 4);
 			t |= hi << 32;
 		}
 
@@ -454,9 +566,6 @@ ar8216_read_port_link(struct ar8xxx_priv *priv, int port,
 	link->tx_flow = !!(status & AR8216_PORT_STATUS_TXFLOW);
 	link->rx_flow = !!(status & AR8216_PORT_STATUS_RXFLOW);
 
-	if (link->aneg && link->duplex && priv->chip->read_port_eee_status)
-		link->eee = priv->chip->read_port_eee_status(priv, port);
-
 	speed = (status & AR8216_PORT_STATUS_SPEED) >>
 		 AR8216_PORT_STATUS_SPEED_S;
 
@@ -542,14 +651,14 @@ ar8216_mangle_rx(struct net_device *dev, struct sk_buff *skb)
 	buf[15 + 2] = vlan & 0xff;
 }
 
-int
+static int
 ar8216_wait_bit(struct ar8xxx_priv *priv, int reg, u32 mask, u32 val)
 {
 	int timeout = 20;
 	u32 t = 0;
 
 	while (1) {
-		t = ar8xxx_read(priv, reg);
+		t = priv->read(priv, reg);
 		if ((t & mask) == val)
 			return 0;
 
@@ -572,10 +681,10 @@ ar8216_vtu_op(struct ar8xxx_priv *priv, u32 op, u32 val)
 	if ((op & AR8216_VTU_OP) == AR8216_VTU_OP_LOAD) {
 		val &= AR8216_VTUDATA_MEMBER;
 		val |= AR8216_VTUDATA_VALID;
-		ar8xxx_write(priv, AR8216_REG_VTU_DATA, val);
+		priv->write(priv, AR8216_REG_VTU_DATA, val);
 	}
 	op |= AR8216_VTU_ACTIVE;
-	ar8xxx_write(priv, AR8216_REG_VTU, op);
+	priv->write(priv, AR8216_REG_VTU, op);
 }
 
 static void
@@ -600,8 +709,7 @@ ar8216_atu_flush(struct ar8xxx_priv *priv)
 
 	ret = ar8216_wait_bit(priv, AR8216_REG_ATU, AR8216_ATU_ACTIVE, 0);
 	if (!ret)
-		ar8xxx_write(priv, AR8216_REG_ATU, AR8216_ATU_OP_FLUSH |
-						   AR8216_ATU_ACTIVE);
+		priv->write(priv, AR8216_REG_ATU, AR8216_ATU_OP_FLUSH);
 
 	return ret;
 }
@@ -609,7 +717,7 @@ ar8216_atu_flush(struct ar8xxx_priv *priv)
 static u32
 ar8216_read_port_status(struct ar8xxx_priv *priv, int port)
 {
-	return ar8xxx_read(priv, AR8216_REG_PORT_STATUS(port));
+	return priv->read(priv, AR8216_REG_PORT_STATUS(port));
 }
 
 static void
@@ -656,12 +764,6 @@ ar8216_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
 static int
 ar8216_hw_init(struct ar8xxx_priv *priv)
 {
-	if (priv->initialized)
-		return 0;
-
-	ar8xxx_phy_init(priv);
-
-	priv->initialized = true;
 	return 0;
 }
 
@@ -669,7 +771,7 @@ static void
 ar8216_init_globals(struct ar8xxx_priv *priv)
 {
 	/* standard atheros magic */
-	ar8xxx_write(priv, 0x38, 0xc000050e);
+	priv->write(priv, 0x38, 0xc000050e);
 
 	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
 		   AR8216_GCTRL_MTU, 1518 + 8 + 2);
@@ -679,14 +781,14 @@ static void
 ar8216_init_port(struct ar8xxx_priv *priv, int port)
 {
 	/* Enable port learning and tx */
-	ar8xxx_write(priv, AR8216_REG_PORT_CTRL(port),
+	priv->write(priv, AR8216_REG_PORT_CTRL(port),
 		AR8216_PORT_CTRL_LEARN |
 		(4 << AR8216_PORT_CTRL_STATE_S));
 
-	ar8xxx_write(priv, AR8216_REG_PORT_VLAN(port), 0);
+	priv->write(priv, AR8216_REG_PORT_VLAN(port), 0);
 
 	if (port == AR8216_PORT_CPU) {
-		ar8xxx_write(priv, AR8216_REG_PORT_STATUS(port),
+		priv->write(priv, AR8216_REG_PORT_STATUS(port),
 			AR8216_PORT_STATUS_LINK_UP |
 			(ar8xxx_has_gige(priv) ?
                                 AR8216_PORT_SPEED_1000M : AR8216_PORT_SPEED_100M) |
@@ -696,11 +798,27 @@ ar8216_init_port(struct ar8xxx_priv *priv, int port)
 			(chip_is_ar8316(priv) ? AR8216_PORT_STATUS_TXFLOW : 0) |
 			AR8216_PORT_STATUS_DUPLEX);
 	} else {
-		ar8xxx_write(priv, AR8216_REG_PORT_STATUS(port),
+		priv->write(priv, AR8216_REG_PORT_STATUS(port),
 			AR8216_PORT_STATUS_LINK_AUTO);
 	}
 }
 
+static const struct ar8xxx_chip ar8216_chip = {
+	.caps = AR8XXX_CAP_MIB_COUNTERS,
+
+	.hw_init = ar8216_hw_init,
+	.init_globals = ar8216_init_globals,
+	.init_port = ar8216_init_port,
+	.setup_port = ar8216_setup_port,
+	.read_port_status = ar8216_read_port_status,
+	.atu_flush = ar8216_atu_flush,
+	.vtu_flush = ar8216_vtu_flush,
+	.vtu_load_vlan = ar8216_vtu_load_vlan,
+
+	.num_mibs = ARRAY_SIZE(ar8216_mibs),
+	.mib_decs = ar8216_mibs,
+};
+
 static void
 ar8236_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
 {
@@ -739,6 +857,29 @@ ar8236_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
 		   (members << AR8236_PORT_VLAN2_MEMBER_S));
 }
 
+static int
+ar8236_hw_init(struct ar8xxx_priv *priv)
+{
+	int i;
+	struct mii_bus *bus;
+
+	if (priv->initialized)
+		return 0;
+
+	/* Initialize the PHYs */
+	bus = priv->mii_bus;
+	for (i = 0; i < 5; i++) {
+		mdiobus_write(bus, i, MII_ADVERTISE,
+			      ADVERTISE_ALL | ADVERTISE_PAUSE_CAP |
+			      ADVERTISE_PAUSE_ASYM);
+		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+	}
+	msleep(1000);
+
+	priv->initialized = true;
+	return 0;
+}
+
 static void
 ar8236_init_globals(struct ar8xxx_priv *priv)
 {
@@ -746,26 +887,35 @@ ar8236_init_globals(struct ar8xxx_priv *priv)
 	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
 		   AR8316_GCTRL_MTU, 9018 + 8 + 2);
 
-	/* enable cpu port to receive arp frames */
-	ar8xxx_reg_set(priv, AR8216_REG_ATU_CTRL,
-		   AR8236_ATU_CTRL_RES);
-
-	/* enable cpu port to receive multicast and broadcast frames */
-	ar8xxx_reg_set(priv, AR8216_REG_FLOOD_MASK,
-		   AR8236_FM_CPU_BROADCAST_EN | AR8236_FM_CPU_BCAST_FWD_EN);
-
 	/* Enable MIB counters */
 	ar8xxx_rmw(priv, AR8216_REG_MIB_FUNC, AR8216_MIB_FUNC | AR8236_MIB_EN,
 		   (AR8216_MIB_FUNC_NO_OP << AR8216_MIB_FUNC_S) |
 		   AR8236_MIB_EN);
 }
 
+static const struct ar8xxx_chip ar8236_chip = {
+	.caps = AR8XXX_CAP_MIB_COUNTERS,
+	.hw_init = ar8236_hw_init,
+	.init_globals = ar8236_init_globals,
+	.init_port = ar8216_init_port,
+	.setup_port = ar8236_setup_port,
+	.read_port_status = ar8216_read_port_status,
+	.atu_flush = ar8216_atu_flush,
+	.vtu_flush = ar8216_vtu_flush,
+	.vtu_load_vlan = ar8216_vtu_load_vlan,
+
+	.num_mibs = ARRAY_SIZE(ar8236_mibs),
+	.mib_decs = ar8236_mibs,
+};
+
 static int
 ar8316_hw_init(struct ar8xxx_priv *priv)
 {
+	int i;
 	u32 val, newval;
+	struct mii_bus *bus;
 
-	val = ar8xxx_read(priv, AR8316_REG_POSTRIP);
+	val = priv->read(priv, AR8316_REG_POSTRIP);
 
 	if (priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
 		if (priv->port4_phy) {
@@ -789,7 +939,7 @@ ar8316_hw_init(struct ar8xxx_priv *priv)
 	if (val == newval)
 		goto out;
 
-	ar8xxx_write(priv, AR8316_REG_POSTRIP, newval);
+	priv->write(priv, AR8316_REG_POSTRIP, newval);
 
 	if (priv->port4_phy &&
 	    priv->phy->interface == PHY_INTERFACE_MODE_RGMII) {
@@ -802,7 +952,17 @@ ar8316_hw_init(struct ar8xxx_priv *priv)
 		msleep(1000);
 	}
 
-	ar8xxx_phy_init(priv);
+	/* Initialize the ports */
+	bus = priv->mii_bus;
+	for (i = 0; i < 5; i++) {
+		/* initialize the port itself */
+		mdiobus_write(bus, i, MII_ADVERTISE,
+			ADVERTISE_ALL | ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
+		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+	}
+
+	msleep(1000);
 
 out:
 	priv->initialized = true;
@@ -813,10 +973,10 @@ static void
 ar8316_init_globals(struct ar8xxx_priv *priv)
 {
 	/* standard atheros magic */
-	ar8xxx_write(priv, 0x38, 0xc000050e);
+	priv->write(priv, 0x38, 0xc000050e);
 
 	/* enable cpu port to receive multicast and broadcast frames */
-	ar8xxx_write(priv, AR8216_REG_FLOOD_MASK, 0x003f003f);
+	priv->write(priv, AR8216_REG_FLOOD_MASK, 0x003f003f);
 
 	/* enable jumbo frames */
 	ar8xxx_rmw(priv, AR8216_REG_GLOBAL_CTRL,
@@ -828,101 +988,974 @@ ar8316_init_globals(struct ar8xxx_priv *priv)
 		   AR8236_MIB_EN);
 }
 
-int
-ar8xxx_sw_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
-		   struct switch_val *val)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	priv->vlan = !!val->value.i;
-	return 0;
-}
+static const struct ar8xxx_chip ar8316_chip = {
+	.caps = AR8XXX_CAP_GIGE | AR8XXX_CAP_MIB_COUNTERS,
+	.hw_init = ar8316_hw_init,
+	.init_globals = ar8316_init_globals,
+	.init_port = ar8216_init_port,
+	.setup_port = ar8216_setup_port,
+	.read_port_status = ar8216_read_port_status,
+	.atu_flush = ar8216_atu_flush,
+	.vtu_flush = ar8216_vtu_flush,
+	.vtu_load_vlan = ar8216_vtu_load_vlan,
 
-int
-ar8xxx_sw_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
-		   struct switch_val *val)
+	.num_mibs = ARRAY_SIZE(ar8236_mibs),
+	.mib_decs = ar8236_mibs,
+};
+
+static u32
+ar8327_get_pad_cfg(struct ar8327_pad_cfg *cfg)
 {
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	val->value.i = priv->vlan;
-	return 0;
-}
+	u32 t;
 
+	if (!cfg)
+		return 0;
 
-int
-ar8xxx_sw_set_pvid(struct switch_dev *dev, int port, int vlan)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	t = 0;
+	switch (cfg->mode) {
+	case AR8327_PAD_NC:
+		break;
 
-	/* make sure no invalid PVIDs get set */
+	case AR8327_PAD_MAC2MAC_MII:
+		t = AR8327_PAD_MAC_MII_EN;
+		if (cfg->rxclk_sel)
+			t |= AR8327_PAD_MAC_MII_RXCLK_SEL;
+		if (cfg->txclk_sel)
+			t |= AR8327_PAD_MAC_MII_TXCLK_SEL;
+		break;
 
-	if (vlan >= dev->vlans)
-		return -EINVAL;
+	case AR8327_PAD_MAC2MAC_GMII:
+		t = AR8327_PAD_MAC_GMII_EN;
+		if (cfg->rxclk_sel)
+			t |= AR8327_PAD_MAC_GMII_RXCLK_SEL;
+		if (cfg->txclk_sel)
+			t |= AR8327_PAD_MAC_GMII_TXCLK_SEL;
+		break;
 
-	priv->pvid[port] = vlan;
-	return 0;
-}
+	case AR8327_PAD_MAC_SGMII:
+		t = AR8327_PAD_SGMII_EN;
 
-int
-ar8xxx_sw_get_pvid(struct switch_dev *dev, int port, int *vlan)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	*vlan = priv->pvid[port];
-	return 0;
-}
+		/*
+		 * WAR for the QUalcomm Atheros AP136 board.
+		 * It seems that RGMII TX/RX delay settings needs to be
+		 * applied for SGMII mode as well, The ethernet is not
+		 * reliable without this.
+		 */
+		t |= cfg->txclk_delay_sel << AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S;
+		t |= cfg->rxclk_delay_sel << AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S;
+		if (cfg->rxclk_delay_en)
+			t |= AR8327_PAD_RGMII_RXCLK_DELAY_EN;
+		if (cfg->txclk_delay_en)
+			t |= AR8327_PAD_RGMII_TXCLK_DELAY_EN;
 
-static int
-ar8xxx_sw_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
-		  struct switch_val *val)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	priv->vlan_id[val->port_vlan] = val->value.i;
-	return 0;
-}
+		if (cfg->sgmii_delay_en)
+			t |= AR8327_PAD_SGMII_DELAY_EN;
 
-static int
-ar8xxx_sw_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
-		  struct switch_val *val)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	val->value.i = priv->vlan_id[val->port_vlan];
-	return 0;
-}
+		break;
 
-int
-ar8xxx_sw_get_port_link(struct switch_dev *dev, int port,
-			struct switch_port_link *link)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	case AR8327_PAD_MAC2PHY_MII:
+		t = AR8327_PAD_PHY_MII_EN;
+		if (cfg->rxclk_sel)
+			t |= AR8327_PAD_PHY_MII_RXCLK_SEL;
+		if (cfg->txclk_sel)
+			t |= AR8327_PAD_PHY_MII_TXCLK_SEL;
+		break;
 
-	ar8216_read_port_link(priv, port, link);
-	return 0;
-}
+	case AR8327_PAD_MAC2PHY_GMII:
+		t = AR8327_PAD_PHY_GMII_EN;
+		if (cfg->pipe_rxclk_sel)
+			t |= AR8327_PAD_PHY_GMII_PIPE_RXCLK_SEL;
+		if (cfg->rxclk_sel)
+			t |= AR8327_PAD_PHY_GMII_RXCLK_SEL;
+		if (cfg->txclk_sel)
+			t |= AR8327_PAD_PHY_GMII_TXCLK_SEL;
+		break;
 
-static int
-ar8xxx_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	u8 ports = priv->vlan_table[val->port_vlan];
-	int i;
+	case AR8327_PAD_MAC_RGMII:
+		t = AR8327_PAD_RGMII_EN;
+		t |= cfg->txclk_delay_sel << AR8327_PAD_RGMII_TXCLK_DELAY_SEL_S;
+		t |= cfg->rxclk_delay_sel << AR8327_PAD_RGMII_RXCLK_DELAY_SEL_S;
+		if (cfg->rxclk_delay_en)
+			t |= AR8327_PAD_RGMII_RXCLK_DELAY_EN;
+		if (cfg->txclk_delay_en)
+			t |= AR8327_PAD_RGMII_TXCLK_DELAY_EN;
+		break;
 
-	val->len = 0;
-	for (i = 0; i < dev->ports; i++) {
-		struct switch_port *p;
+	case AR8327_PAD_PHY_GMII:
+		t = AR8327_PAD_PHYX_GMII_EN;
+		break;
 
-		if (!(ports & (1 << i)))
-			continue;
+	case AR8327_PAD_PHY_RGMII:
+		t = AR8327_PAD_PHYX_RGMII_EN;
+		break;
+
+	case AR8327_PAD_PHY_MII:
+		t = AR8327_PAD_PHYX_MII_EN;
+		break;
+	}
+
+	return t;
+}
+
+static void
+ar8327_phy_fixup(struct ar8xxx_priv *priv, int phy)
+{
+	switch (priv->chip_rev) {
+	case 1:
+		/* For 100M waveform */
+		ar8xxx_phy_dbg_write(priv, phy, 0, 0x02ea);
+		/* Turn on Gigabit clock */
+		ar8xxx_phy_dbg_write(priv, phy, 0x3d, 0x68a0);
+		break;
+
+	case 2:
+		ar8xxx_phy_mmd_write(priv, phy, 0x7, 0x3c);
+		ar8xxx_phy_mmd_write(priv, phy, 0x4007, 0x0);
+		/* fallthrough */
+	case 4:
+		ar8xxx_phy_mmd_write(priv, phy, 0x3, 0x800d);
+		ar8xxx_phy_mmd_write(priv, phy, 0x4003, 0x803f);
+
+		ar8xxx_phy_dbg_write(priv, phy, 0x3d, 0x6860);
+		ar8xxx_phy_dbg_write(priv, phy, 0x5, 0x2c46);
+		ar8xxx_phy_dbg_write(priv, phy, 0x3c, 0x6000);
+		break;
+	}
+}
+
+static u32
+ar8327_get_port_init_status(struct ar8327_port_cfg *cfg)
+{
+	u32 t;
+
+	if (!cfg->force_link)
+		return AR8216_PORT_STATUS_LINK_AUTO;
+
+	t = AR8216_PORT_STATUS_TXMAC | AR8216_PORT_STATUS_RXMAC;
+	t |= cfg->duplex ? AR8216_PORT_STATUS_DUPLEX : 0;
+	t |= cfg->rxpause ? AR8216_PORT_STATUS_RXFLOW : 0;
+	t |= cfg->txpause ? AR8216_PORT_STATUS_TXFLOW : 0;
+
+	switch (cfg->speed) {
+	case AR8327_PORT_SPEED_10:
+		t |= AR8216_PORT_SPEED_10M;
+		break;
+	case AR8327_PORT_SPEED_100:
+		t |= AR8216_PORT_SPEED_100M;
+		break;
+	case AR8327_PORT_SPEED_1000:
+		t |= AR8216_PORT_SPEED_1000M;
+		break;
+	}
+
+	return t;
+}
+
+#define AR8327_LED_ENTRY(_num, _reg, _shift) \
+	[_num] = { .reg = (_reg), .shift = (_shift) }
+
+static const struct ar8327_led_entry
+ar8327_led_map[AR8327_NUM_LEDS] = {
+	AR8327_LED_ENTRY(AR8327_LED_PHY0_0, 0, 14),
+	AR8327_LED_ENTRY(AR8327_LED_PHY0_1, 1, 14),
+	AR8327_LED_ENTRY(AR8327_LED_PHY0_2, 2, 14),
+
+	AR8327_LED_ENTRY(AR8327_LED_PHY1_0, 3, 8),
+	AR8327_LED_ENTRY(AR8327_LED_PHY1_1, 3, 10),
+	AR8327_LED_ENTRY(AR8327_LED_PHY1_2, 3, 12),
+
+	AR8327_LED_ENTRY(AR8327_LED_PHY2_0, 3, 14),
+	AR8327_LED_ENTRY(AR8327_LED_PHY2_1, 3, 16),
+	AR8327_LED_ENTRY(AR8327_LED_PHY2_2, 3, 18),
+
+	AR8327_LED_ENTRY(AR8327_LED_PHY3_0, 3, 20),
+	AR8327_LED_ENTRY(AR8327_LED_PHY3_1, 3, 22),
+	AR8327_LED_ENTRY(AR8327_LED_PHY3_2, 3, 24),
+
+	AR8327_LED_ENTRY(AR8327_LED_PHY4_0, 0, 30),
+	AR8327_LED_ENTRY(AR8327_LED_PHY4_1, 1, 30),
+	AR8327_LED_ENTRY(AR8327_LED_PHY4_2, 2, 30),
+};
+
+static void
+ar8327_set_led_pattern(struct ar8xxx_priv *priv, unsigned int led_num,
+		       enum ar8327_led_pattern pattern)
+{
+	const struct ar8327_led_entry *entry;
+
+	entry = &ar8327_led_map[led_num];
+	ar8xxx_rmw(priv, AR8327_REG_LED_CTRL(entry->reg),
+		   (3 << entry->shift), pattern << entry->shift);
+}
+
+static void
+ar8327_led_work_func(struct work_struct *work)
+{
+	struct ar8327_led *aled;
+	u8 pattern;
+
+	aled = container_of(work, struct ar8327_led, led_work);
+
+	spin_lock(&aled->lock);
+	pattern = aled->pattern;
+	spin_unlock(&aled->lock);
+
+	ar8327_set_led_pattern(aled->sw_priv, aled->led_num,
+			       pattern);
+}
+
+static void
+ar8327_led_schedule_change(struct ar8327_led *aled, u8 pattern)
+{
+	if (aled->pattern == pattern)
+		return;
+
+	aled->pattern = pattern;
+	schedule_work(&aled->led_work);
+}
+
+static inline struct ar8327_led *
+led_cdev_to_ar8327_led(struct led_classdev *led_cdev)
+{
+	return container_of(led_cdev, struct ar8327_led, cdev);
+}
+
+static int
+ar8327_led_blink_set(struct led_classdev *led_cdev,
+		     unsigned long *delay_on,
+		     unsigned long *delay_off)
+{
+	struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
+
+	if (*delay_on == 0 && *delay_off == 0) {
+		*delay_on = 125;
+		*delay_off = 125;
+	}
+
+	if (*delay_on != 125 || *delay_off != 125) {
+		/*
+		 * The hardware only supports blinking at 4Hz. Fall back
+		 * to software implementation in other cases.
+		 */
+		return -EINVAL;
+	}
+
+	spin_lock(&aled->lock);
+
+	aled->enable_hw_mode = false;
+	ar8327_led_schedule_change(aled, AR8327_LED_PATTERN_BLINK);
+
+	spin_unlock(&aled->lock);
+
+	return 0;
+}
+
+static void
+ar8327_led_set_brightness(struct led_classdev *led_cdev,
+			  enum led_brightness brightness)
+{
+	struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
+	u8 pattern;
+	bool active;
+
+	active = (brightness != LED_OFF);
+	active ^= aled->active_low;
+
+	pattern = (active) ? AR8327_LED_PATTERN_ON :
+			     AR8327_LED_PATTERN_OFF;
+
+	spin_lock(&aled->lock);
+
+	aled->enable_hw_mode = false;
+	ar8327_led_schedule_change(aled, pattern);
+
+	spin_unlock(&aled->lock);
+}
+
+static ssize_t
+ar8327_led_enable_hw_mode_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
+	ssize_t ret = 0;
+
+	spin_lock(&aled->lock);
+	ret += sprintf(buf, "%d\n", aled->enable_hw_mode);
+	spin_unlock(&aled->lock);
+
+	return ret;
+}
+
+static ssize_t
+ar8327_led_enable_hw_mode_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf,
+				size_t size)
+{
+        struct led_classdev *led_cdev = dev_get_drvdata(dev);
+	struct ar8327_led *aled = led_cdev_to_ar8327_led(led_cdev);
+	u8 pattern;
+	u8 value;
+	int ret;
+
+	ret = kstrtou8(buf, 10, &value);
+	if (ret < 0)
+		return -EINVAL;
+
+	spin_lock(&aled->lock);
+
+	aled->enable_hw_mode = !!value;
+	if (aled->enable_hw_mode)
+		pattern = AR8327_LED_PATTERN_RULE;
+	else
+		pattern = AR8327_LED_PATTERN_OFF;
+
+	ar8327_led_schedule_change(aled, pattern);
+
+	spin_unlock(&aled->lock);
+
+	return size;
+}
+
+static DEVICE_ATTR(enable_hw_mode,  S_IRUGO | S_IWUSR,
+		   ar8327_led_enable_hw_mode_show,
+		   ar8327_led_enable_hw_mode_store);
+
+static int
+ar8327_led_register(struct ar8xxx_priv *priv, struct ar8327_led *aled)
+{
+	int ret;
+
+	ret = led_classdev_register(NULL, &aled->cdev);
+	if (ret < 0)
+		return ret;
+
+	if (aled->mode == AR8327_LED_MODE_HW) {
+		ret = device_create_file(aled->cdev.dev,
+					 &dev_attr_enable_hw_mode);
+		if (ret)
+			goto err_unregister;
+	}
+
+	return 0;
+
+err_unregister:
+	led_classdev_unregister(&aled->cdev);
+	return ret;
+}
+
+static void
+ar8327_led_unregister(struct ar8327_led *aled)
+{
+	if (aled->mode == AR8327_LED_MODE_HW)
+		device_remove_file(aled->cdev.dev, &dev_attr_enable_hw_mode);
+
+	led_classdev_unregister(&aled->cdev);
+	cancel_work_sync(&aled->led_work);
+}
+
+static int
+ar8327_led_create(struct ar8xxx_priv *priv,
+		  const struct ar8327_led_info *led_info)
+{
+	struct ar8327_data *data = &priv->chip_data.ar8327;
+	struct ar8327_led *aled;
+	int ret;
+
+	if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
+		return 0;
+
+	if (!led_info->name)
+		return -EINVAL;
+
+	if (led_info->led_num >= AR8327_NUM_LEDS)
+		return -EINVAL;
+
+	aled = kzalloc(sizeof(*aled) + strlen(led_info->name) + 1,
+		       GFP_KERNEL);
+	if (!aled)
+		return -ENOMEM;
+
+	aled->sw_priv = priv;
+	aled->led_num = led_info->led_num;
+	aled->active_low = led_info->active_low;
+	aled->mode = led_info->mode;
+
+	if (aled->mode == AR8327_LED_MODE_HW)
+		aled->enable_hw_mode = true;
+
+	aled->name = (char *)(aled + 1);
+	strcpy(aled->name, led_info->name);
+
+	aled->cdev.name = aled->name;
+	aled->cdev.brightness_set = ar8327_led_set_brightness;
+	aled->cdev.blink_set = ar8327_led_blink_set;
+	aled->cdev.default_trigger = led_info->default_trigger;
+
+	spin_lock_init(&aled->lock);
+	mutex_init(&aled->mutex);
+	INIT_WORK(&aled->led_work, ar8327_led_work_func);
+
+	ret = ar8327_led_register(priv, aled);
+	if (ret)
+		goto err_free;
+
+	data->leds[data->num_leds++] = aled;
+
+	return 0;
+
+err_free:
+	kfree(aled);
+	return ret;
+}
+
+static void
+ar8327_led_destroy(struct ar8327_led *aled)
+{
+	ar8327_led_unregister(aled);
+	kfree(aled);
+}
+
+static void
+ar8327_leds_init(struct ar8xxx_priv *priv)
+{
+	struct ar8327_data *data;
+	unsigned i;
+
+	if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
+		return;
+
+	data = &priv->chip_data.ar8327;
+
+	for (i = 0; i < data->num_leds; i++) {
+		struct ar8327_led *aled;
+
+		aled = data->leds[i];
+
+		if (aled->enable_hw_mode)
+			aled->pattern = AR8327_LED_PATTERN_RULE;
+		else
+			aled->pattern = AR8327_LED_PATTERN_OFF;
+
+		ar8327_set_led_pattern(priv, aled->led_num, aled->pattern);
+	}
+}
+
+static void
+ar8327_leds_cleanup(struct ar8xxx_priv *priv)
+{
+	struct ar8327_data *data = &priv->chip_data.ar8327;
+	unsigned i;
+
+	if (!IS_ENABLED(CONFIG_AR8216_PHY_LEDS))
+		return;
+
+	for (i = 0; i < data->num_leds; i++) {
+		struct ar8327_led *aled;
+
+		aled = data->leds[i];
+		ar8327_led_destroy(aled);
+	}
+
+	kfree(data->leds);
+}
+
+static int
+ar8327_hw_config_pdata(struct ar8xxx_priv *priv,
+		       struct ar8327_platform_data *pdata)
+{
+	struct ar8327_led_cfg *led_cfg;
+	struct ar8327_data *data;
+	u32 pos, new_pos;
+	u32 t;
+
+	if (!pdata)
+		return -EINVAL;
+
+	priv->get_port_link = pdata->get_port_link;
+
+	data = &priv->chip_data.ar8327;
+
+	data->port0_status = ar8327_get_port_init_status(&pdata->port0_cfg);
+	data->port6_status = ar8327_get_port_init_status(&pdata->port6_cfg);
+
+	t = ar8327_get_pad_cfg(pdata->pad0_cfg);
+	if (chip_is_ar8337(priv))
+		t |= AR8337_PAD_MAC06_EXCHANGE_EN;
+
+	priv->write(priv, AR8327_REG_PAD0_MODE, t);
+	t = ar8327_get_pad_cfg(pdata->pad5_cfg);
+	priv->write(priv, AR8327_REG_PAD5_MODE, t);
+	t = ar8327_get_pad_cfg(pdata->pad6_cfg);
+	priv->write(priv, AR8327_REG_PAD6_MODE, t);
+
+	pos = priv->read(priv, AR8327_REG_POWER_ON_STRIP);
+	new_pos = pos;
+
+	led_cfg = pdata->led_cfg;
+	if (led_cfg) {
+		if (led_cfg->open_drain)
+			new_pos |= AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+		else
+			new_pos &= ~AR8327_POWER_ON_STRIP_LED_OPEN_EN;
+
+		priv->write(priv, AR8327_REG_LED_CTRL0, led_cfg->led_ctrl0);
+		priv->write(priv, AR8327_REG_LED_CTRL1, led_cfg->led_ctrl1);
+		priv->write(priv, AR8327_REG_LED_CTRL2, led_cfg->led_ctrl2);
+		priv->write(priv, AR8327_REG_LED_CTRL3, led_cfg->led_ctrl3);
+
+		if (new_pos != pos)
+			new_pos |= AR8327_POWER_ON_STRIP_POWER_ON_SEL;
+	}
+
+	if (pdata->sgmii_cfg) {
+		t = pdata->sgmii_cfg->sgmii_ctrl;
+		if (priv->chip_rev == 1)
+			t |= AR8327_SGMII_CTRL_EN_PLL |
+			     AR8327_SGMII_CTRL_EN_RX |
+			     AR8327_SGMII_CTRL_EN_TX;
+		else
+			t &= ~(AR8327_SGMII_CTRL_EN_PLL |
+			       AR8327_SGMII_CTRL_EN_RX |
+			       AR8327_SGMII_CTRL_EN_TX);
+
+		priv->write(priv, AR8327_REG_SGMII_CTRL, t);
+
+		if (pdata->sgmii_cfg->serdes_aen)
+			new_pos &= ~AR8327_POWER_ON_STRIP_SERDES_AEN;
+		else
+			new_pos |= AR8327_POWER_ON_STRIP_SERDES_AEN;
+	}
+
+	priv->write(priv, AR8327_REG_POWER_ON_STRIP, new_pos);
+
+	if (pdata->leds && pdata->num_leds) {
+		int i;
+
+		data->leds = kzalloc(pdata->num_leds * sizeof(void *),
+				     GFP_KERNEL);
+		if (!data->leds)
+			return -ENOMEM;
+
+		for (i = 0; i < pdata->num_leds; i++)
+			ar8327_led_create(priv, &pdata->leds[i]);
+	}
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static int
+ar8327_hw_config_of(struct ar8xxx_priv *priv, struct device_node *np)
+{
+	const __be32 *paddr;
+	int len;
+	int i;
+
+	paddr = of_get_property(np, "qca,ar8327-initvals", &len);
+	if (!paddr || len < (2 * sizeof(*paddr)))
+		return -EINVAL;
+
+	len /= sizeof(*paddr);
+
+	for (i = 0; i < len - 1; i += 2) {
+		u32 reg;
+		u32 val;
+
+		reg = be32_to_cpup(paddr + i);
+		val = be32_to_cpup(paddr + i + 1);
+
+		switch (reg) {
+		case AR8327_REG_PORT_STATUS(0):
+			priv->chip_data.ar8327.port0_status = val;
+			break;
+		case AR8327_REG_PORT_STATUS(6):
+			priv->chip_data.ar8327.port6_status = val;
+			break;
+		default:
+			priv->write(priv, reg, val);
+			break;
+		}
+	}
+
+	return 0;
+}
+#else
+static inline int
+ar8327_hw_config_of(struct ar8xxx_priv *priv, struct device_node *np)
+{
+	return -EINVAL;
+}
+#endif
+
+static int
+ar8327_hw_init(struct ar8xxx_priv *priv)
+{
+	struct mii_bus *bus;
+	int ret;
+	int i;
+
+	if (priv->phy->dev.of_node)
+		ret = ar8327_hw_config_of(priv, priv->phy->dev.of_node);
+	else
+		ret = ar8327_hw_config_pdata(priv,
+					     priv->phy->dev.platform_data);
+
+	if (ret)
+		return ret;
+
+	ar8327_leds_init(priv);
+
+	bus = priv->mii_bus;
+	for (i = 0; i < AR8327_NUM_PHYS; i++) {
+		ar8327_phy_fixup(priv, i);
+
+		/* start aneg on the PHY */
+		mdiobus_write(bus, i, MII_ADVERTISE, ADVERTISE_ALL |
+						     ADVERTISE_PAUSE_CAP |
+						     ADVERTISE_PAUSE_ASYM);
+		mdiobus_write(bus, i, MII_CTRL1000, ADVERTISE_1000FULL);
+		mdiobus_write(bus, i, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+	}
+
+	msleep(1000);
+
+	return 0;
+}
+
+static void
+ar8327_cleanup(struct ar8xxx_priv *priv)
+{
+	ar8327_leds_cleanup(priv);
+}
+
+static void
+ar8327_init_globals(struct ar8xxx_priv *priv)
+{
+	u32 t;
+
+	/* enable CPU port and disable mirror port */
+	t = AR8327_FWD_CTRL0_CPU_PORT_EN |
+	    AR8327_FWD_CTRL0_MIRROR_PORT;
+	priv->write(priv, AR8327_REG_FWD_CTRL0, t);
+
+	/* forward multicast and broadcast frames to CPU */
+	t = (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_UC_FLOOD_S) |
+	    (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_MC_FLOOD_S) |
+	    (AR8327_PORTS_ALL << AR8327_FWD_CTRL1_BC_FLOOD_S);
+	priv->write(priv, AR8327_REG_FWD_CTRL1, t);
+
+	/* enable jumbo frames */
+	ar8xxx_rmw(priv, AR8327_REG_MAX_FRAME_SIZE,
+		   AR8327_MAX_FRAME_SIZE_MTU, 9018 + 8 + 2);
+
+	/* Enable MIB counters */
+	ar8xxx_reg_set(priv, AR8327_REG_MODULE_EN,
+		       AR8327_MODULE_EN_MIB);
+
+	/* Disable EEE on all ports due to stability issues */
+	t = priv->read(priv, AR8327_REG_EEE_CTRL);
+	t |= AR8327_EEE_CTRL_DISABLE_PHY(0) |
+	     AR8327_EEE_CTRL_DISABLE_PHY(1) |
+	     AR8327_EEE_CTRL_DISABLE_PHY(2) |
+	     AR8327_EEE_CTRL_DISABLE_PHY(3) |
+	     AR8327_EEE_CTRL_DISABLE_PHY(4);
+	priv->write(priv, AR8327_REG_EEE_CTRL, t);
+}
+
+static void
+ar8327_init_port(struct ar8xxx_priv *priv, int port)
+{
+	u32 t;
+
+	if (port == AR8216_PORT_CPU)
+		t = priv->chip_data.ar8327.port0_status;
+	else if (port == 6)
+		t = priv->chip_data.ar8327.port6_status;
+	else
+		t = AR8216_PORT_STATUS_LINK_AUTO;
+
+	priv->write(priv, AR8327_REG_PORT_STATUS(port), t);
+	priv->write(priv, AR8327_REG_PORT_HEADER(port), 0);
+
+	t = 1 << AR8327_PORT_VLAN0_DEF_SVID_S;
+	t |= 1 << AR8327_PORT_VLAN0_DEF_CVID_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN0(port), t);
+
+	t = AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH << AR8327_PORT_VLAN1_OUT_MODE_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN1(port), t);
+
+	t = AR8327_PORT_LOOKUP_LEARN;
+	t |= AR8216_PORT_STATE_FORWARD << AR8327_PORT_LOOKUP_STATE_S;
+	priv->write(priv, AR8327_REG_PORT_LOOKUP(port), t);
+}
+
+static u32
+ar8327_read_port_status(struct ar8xxx_priv *priv, int port)
+{
+	return priv->read(priv, AR8327_REG_PORT_STATUS(port));
+}
+
+static int
+ar8327_atu_flush(struct ar8xxx_priv *priv)
+{
+	int ret;
+
+	ret = ar8216_wait_bit(priv, AR8327_REG_ATU_FUNC,
+			      AR8327_ATU_FUNC_BUSY, 0);
+	if (!ret)
+		priv->write(priv, AR8327_REG_ATU_FUNC,
+			    AR8327_ATU_FUNC_OP_FLUSH);
+
+	return ret;
+}
+
+static void
+ar8327_vtu_op(struct ar8xxx_priv *priv, u32 op, u32 val)
+{
+	if (ar8216_wait_bit(priv, AR8327_REG_VTU_FUNC1,
+			    AR8327_VTU_FUNC1_BUSY, 0))
+		return;
+
+	if ((op & AR8327_VTU_FUNC1_OP) == AR8327_VTU_FUNC1_OP_LOAD)
+		priv->write(priv, AR8327_REG_VTU_FUNC0, val);
+
+	op |= AR8327_VTU_FUNC1_BUSY;
+	priv->write(priv, AR8327_REG_VTU_FUNC1, op);
+}
+
+static void
+ar8327_vtu_flush(struct ar8xxx_priv *priv)
+{
+	ar8327_vtu_op(priv, AR8327_VTU_FUNC1_OP_FLUSH, 0);
+}
+
+static void
+ar8327_vtu_load_vlan(struct ar8xxx_priv *priv, u32 vid, u32 port_mask)
+{
+	u32 op;
+	u32 val;
+	int i;
+
+	op = AR8327_VTU_FUNC1_OP_LOAD | (vid << AR8327_VTU_FUNC1_VID_S);
+	val = AR8327_VTU_FUNC0_VALID | AR8327_VTU_FUNC0_IVL;
+	for (i = 0; i < AR8327_NUM_PORTS; i++) {
+		u32 mode;
+
+		if ((port_mask & BIT(i)) == 0)
+			mode = AR8327_VTU_FUNC0_EG_MODE_NOT;
+		else if (priv->vlan == 0)
+			mode = AR8327_VTU_FUNC0_EG_MODE_KEEP;
+		else if ((priv->vlan_tagged & BIT(i)) || (priv->vlan_id[priv->pvid[i]] != vid))
+			mode = AR8327_VTU_FUNC0_EG_MODE_TAG;
+		else
+			mode = AR8327_VTU_FUNC0_EG_MODE_UNTAG;
+
+		val |= mode << AR8327_VTU_FUNC0_EG_MODE_S(i);
+	}
+	ar8327_vtu_op(priv, op, val);
+}
+
+static void
+ar8327_setup_port(struct ar8xxx_priv *priv, int port, u32 members)
+{
+	u32 t;
+	u32 egress, ingress;
+	u32 pvid;
+
+	if (priv->vlan) {
+		pvid = priv->vlan_id[priv->pvid[port]];
+		egress = AR8327_PORT_VLAN1_OUT_MODE_UNMOD;
+		ingress = AR8216_IN_SECURE;
+	} else {
+		pvid = port;
+		egress = AR8327_PORT_VLAN1_OUT_MODE_UNTOUCH;
+		ingress = AR8216_IN_PORT_ONLY;
+	}
+
+	t = pvid << AR8327_PORT_VLAN0_DEF_SVID_S;
+	t |= pvid << AR8327_PORT_VLAN0_DEF_CVID_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN0(port), t);
+
+	t = AR8327_PORT_VLAN1_PORT_VLAN_PROP;
+	t |= egress << AR8327_PORT_VLAN1_OUT_MODE_S;
+	priv->write(priv, AR8327_REG_PORT_VLAN1(port), t);
+
+	t = members;
+	t |= AR8327_PORT_LOOKUP_LEARN;
+	t |= ingress << AR8327_PORT_LOOKUP_IN_MODE_S;
+	t |= AR8216_PORT_STATE_FORWARD << AR8327_PORT_LOOKUP_STATE_S;
+	priv->write(priv, AR8327_REG_PORT_LOOKUP(port), t);
+}
+
+static const struct ar8xxx_chip ar8327_chip = {
+	.caps = AR8XXX_CAP_GIGE | AR8XXX_CAP_MIB_COUNTERS,
+	.hw_init = ar8327_hw_init,
+	.cleanup = ar8327_cleanup,
+	.init_globals = ar8327_init_globals,
+	.init_port = ar8327_init_port,
+	.setup_port = ar8327_setup_port,
+	.read_port_status = ar8327_read_port_status,
+	.atu_flush = ar8327_atu_flush,
+	.vtu_flush = ar8327_vtu_flush,
+	.vtu_load_vlan = ar8327_vtu_load_vlan,
+
+	.num_mibs = ARRAY_SIZE(ar8236_mibs),
+	.mib_decs = ar8236_mibs,
+};
+
+static int
+ar8xxx_sw_set_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		   struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	priv->vlan = !!val->value.i;
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_vlan(struct switch_dev *dev, const struct switch_attr *attr,
+		   struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	val->value.i = priv->vlan;
+	return 0;
+}
+
+
+static int
+ar8xxx_sw_set_pvid(struct switch_dev *dev, int port, int vlan)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	/* make sure no invalid PVIDs get set */
+
+	if (vlan >= dev->vlans)
+		return -EINVAL;
+
+	priv->pvid[port] = vlan;
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_pvid(struct switch_dev *dev, int port, int *vlan)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	*vlan = priv->pvid[port];
+	return 0;
+}
+
+static int
+ar8xxx_sw_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		  struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	priv->vlan_id[val->port_vlan] = val->value.i;
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
+		  struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	val->value.i = priv->vlan_id[val->port_vlan];
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_port_link(struct switch_dev *dev, int port,
+			struct switch_port_link *link)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+
+	ar8216_read_port_link(priv, port, link);
+	return 0;
+}
+
+static int
+ar8xxx_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	u8 ports = priv->vlan_table[val->port_vlan];
+	int i;
+
+	val->len = 0;
+	for (i = 0; i < dev->ports; i++) {
+		struct switch_port *p;
+
+		if (!(ports & (1 << i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+		if (priv->vlan_tagged & (1 << i))
+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		else
+			p->flags = 0;
+	}
+	return 0;
+}
+
+static int
+ar8327_sw_get_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	u8 ports = priv->vlan_table[val->port_vlan];
+	int i;
+
+	val->len = 0;
+	for (i = 0; i < dev->ports; i++) {
+		struct switch_port *p;
+
+		if (!(ports & (1 << i)))
+			continue;
+
+		p = &val->value.ports[val->len++];
+		p->id = i;
+		if ((priv->vlan_tagged & (1 << i)) || (priv->pvid[i] != val->port_vlan))
+			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
+		else
+			p->flags = 0;
+	}
+	return 0;
+}
+
+static int
+ar8xxx_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
+{
+	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
+	u8 *vt = &priv->vlan_table[val->port_vlan];
+	int i, j;
+
+	*vt = 0;
+	for (i = 0; i < val->len; i++) {
+		struct switch_port *p = &val->value.ports[i];
+
+		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
+			priv->vlan_tagged |= (1 << p->id);
+		} else {
+			priv->vlan_tagged &= ~(1 << p->id);
+			priv->pvid[p->id] = val->port_vlan;
+
+			/* make sure that an untagged port does not
+			 * appear in other vlans */
+			for (j = 0; j < AR8X16_MAX_VLANS; j++) {
+				if (j == val->port_vlan)
+					continue;
+				priv->vlan_table[j] &= ~(1 << p->id);
+			}
+		}
 
-		p = &val->value.ports[val->len++];
-		p->id = i;
-		if (priv->vlan_tagged & (1 << i))
-			p->flags = (1 << SWITCH_PORT_FLAG_TAGGED);
-		else
-			p->flags = 0;
+		*vt |= 1 << p->id;
 	}
 	return 0;
 }
 
 static int
-ar8xxx_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
+ar8327_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
 	u8 *vt = &priv->vlan_table[val->port_vlan];
@@ -933,18 +1966,12 @@ ar8xxx_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
 		struct switch_port *p = &val->value.ports[i];
 
 		if (p->flags & (1 << SWITCH_PORT_FLAG_TAGGED)) {
-			priv->vlan_tagged |= (1 << p->id);
+			if (val->port_vlan == priv->pvid[p->id]) {
+				priv->vlan_tagged |= (1 << p->id);
+			}
 		} else {
 			priv->vlan_tagged &= ~(1 << p->id);
 			priv->pvid[p->id] = val->port_vlan;
-
-			/* make sure that an untagged port does not
-			 * appear in other vlans */
-			for (j = 0; j < AR8X16_MAX_VLANS; j++) {
-				if (j == val->port_vlan)
-					continue;
-				priv->vlan_table[j] &= ~(1 << p->id);
-			}
 		}
 
 		*vt |= 1 << p->id;
@@ -953,6 +1980,47 @@ ar8xxx_sw_set_ports(struct switch_dev *dev, struct switch_val *val)
 }
 
 static void
+ar8327_set_mirror_regs(struct ar8xxx_priv *priv)
+{
+	int port;
+
+	/* reset all mirror registers */
+	ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL0,
+		   AR8327_FWD_CTRL0_MIRROR_PORT,
+		   (0xF << AR8327_FWD_CTRL0_MIRROR_PORT_S));
+	for (port = 0; port < AR8327_NUM_PORTS; port++) {
+		ar8xxx_rmw(priv, AR8327_REG_PORT_LOOKUP(port),
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN,
+			   0);
+
+		ar8xxx_rmw(priv, AR8327_REG_PORT_HOL_CTRL1(port),
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN,
+			   0);
+	}
+
+	/* now enable mirroring if necessary */
+	if (priv->source_port >= AR8327_NUM_PORTS ||
+	    priv->monitor_port >= AR8327_NUM_PORTS ||
+	    priv->source_port == priv->monitor_port) {
+		return;
+	}
+
+	ar8xxx_rmw(priv, AR8327_REG_FWD_CTRL0,
+		   AR8327_FWD_CTRL0_MIRROR_PORT,
+		   (priv->monitor_port << AR8327_FWD_CTRL0_MIRROR_PORT_S));
+
+	if (priv->mirror_rx)
+		ar8xxx_rmw(priv, AR8327_REG_PORT_LOOKUP(priv->source_port),
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN,
+			   AR8327_PORT_LOOKUP_ING_MIRROR_EN);
+
+	if (priv->mirror_tx)
+		ar8xxx_rmw(priv, AR8327_REG_PORT_HOL_CTRL1(priv->source_port),
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN,
+			   AR8327_PORT_HOL_CTRL1_EG_MIRROR_EN);
+}
+
+static void
 ar8216_set_mirror_regs(struct ar8xxx_priv *priv)
 {
 	int port;
@@ -962,11 +2030,13 @@ ar8216_set_mirror_regs(struct ar8xxx_priv *priv)
 		   AR8216_GLOBAL_CPUPORT_MIRROR_PORT,
 		   (0xF << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
 	for (port = 0; port < AR8216_NUM_PORTS; port++) {
-		ar8xxx_reg_clear(priv, AR8216_REG_PORT_CTRL(port),
-			   AR8216_PORT_CTRL_MIRROR_RX);
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
+			   AR8216_PORT_CTRL_MIRROR_RX,
+			   0);
 
-		ar8xxx_reg_clear(priv, AR8216_REG_PORT_CTRL(port),
-			   AR8216_PORT_CTRL_MIRROR_TX);
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(port),
+			   AR8216_PORT_CTRL_MIRROR_TX,
+			   0);
 	}
 
 	/* now enable mirroring if necessary */
@@ -981,15 +2051,27 @@ ar8216_set_mirror_regs(struct ar8xxx_priv *priv)
 		   (priv->monitor_port << AR8216_GLOBAL_CPUPORT_MIRROR_PORT_S));
 
 	if (priv->mirror_rx)
-		ar8xxx_reg_set(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+			   AR8216_PORT_CTRL_MIRROR_RX,
 			   AR8216_PORT_CTRL_MIRROR_RX);
 
 	if (priv->mirror_tx)
-		ar8xxx_reg_set(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+		ar8xxx_rmw(priv, AR8216_REG_PORT_CTRL(priv->source_port),
+			   AR8216_PORT_CTRL_MIRROR_TX,
 			   AR8216_PORT_CTRL_MIRROR_TX);
 }
 
-int
+static void
+ar8xxx_set_mirror_regs(struct ar8xxx_priv *priv)
+{
+	if (chip_is_ar8327(priv) || chip_is_ar8337(priv)) {
+		ar8327_set_mirror_regs(priv);
+	} else {
+		ar8216_set_mirror_regs(priv);
+	}
+}
+
+static int
 ar8xxx_sw_hw_apply(struct switch_dev *dev)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
@@ -1036,17 +2118,16 @@ ar8xxx_sw_hw_apply(struct switch_dev *dev)
 		priv->chip->setup_port(priv, i, portmask[i]);
 	}
 
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 
 	mutex_unlock(&priv->reg_mutex);
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_reset_switch(struct switch_dev *dev)
 {
 	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	const struct ar8xxx_chip *chip = priv->chip;
 	int i;
 
 	mutex_lock(&priv->reg_mutex);
@@ -1058,21 +2139,21 @@ ar8xxx_sw_reset_switch(struct switch_dev *dev)
 
 	/* Configure all ports */
 	for (i = 0; i < dev->ports; i++)
-		chip->init_port(priv, i);
+		priv->chip->init_port(priv, i);
 
 	priv->mirror_rx = false;
 	priv->mirror_tx = false;
 	priv->source_port = 0;
 	priv->monitor_port = 0;
 
-	chip->init_globals(priv);
+	priv->chip->init_globals(priv);
 
 	mutex_unlock(&priv->reg_mutex);
 
-	return chip->sw_hw_apply(dev);
+	return ar8xxx_sw_hw_apply(dev);
 }
 
-int
+static int
 ar8xxx_sw_set_reset_mibs(struct switch_dev *dev,
 			 const struct switch_attr *attr,
 			 struct switch_val *val)
@@ -1100,7 +2181,7 @@ unlock:
 	return ret;
 }
 
-int
+static int
 ar8xxx_sw_set_mirror_rx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
@@ -1109,13 +2190,13 @@ ar8xxx_sw_set_mirror_rx_enable(struct switch_dev *dev,
 
 	mutex_lock(&priv->reg_mutex);
 	priv->mirror_rx = !!val->value.i;
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 	mutex_unlock(&priv->reg_mutex);
 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_mirror_rx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
@@ -1125,7 +2206,7 @@ ar8xxx_sw_get_mirror_rx_enable(struct switch_dev *dev,
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_set_mirror_tx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
@@ -1134,13 +2215,13 @@ ar8xxx_sw_set_mirror_tx_enable(struct switch_dev *dev,
 
 	mutex_lock(&priv->reg_mutex);
 	priv->mirror_tx = !!val->value.i;
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 	mutex_unlock(&priv->reg_mutex);
 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_mirror_tx_enable(struct switch_dev *dev,
 			       const struct switch_attr *attr,
 			       struct switch_val *val)
@@ -1150,7 +2231,7 @@ ar8xxx_sw_get_mirror_tx_enable(struct switch_dev *dev,
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_set_mirror_monitor_port(struct switch_dev *dev,
 				  const struct switch_attr *attr,
 				  struct switch_val *val)
@@ -1159,13 +2240,13 @@ ar8xxx_sw_set_mirror_monitor_port(struct switch_dev *dev,
 
 	mutex_lock(&priv->reg_mutex);
 	priv->monitor_port = val->value.i;
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 	mutex_unlock(&priv->reg_mutex);
 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_mirror_monitor_port(struct switch_dev *dev,
 				  const struct switch_attr *attr,
 				  struct switch_val *val)
@@ -1175,7 +2256,7 @@ ar8xxx_sw_get_mirror_monitor_port(struct switch_dev *dev,
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_set_mirror_source_port(struct switch_dev *dev,
 				 const struct switch_attr *attr,
 				 struct switch_val *val)
@@ -1184,13 +2265,13 @@ ar8xxx_sw_set_mirror_source_port(struct switch_dev *dev,
 
 	mutex_lock(&priv->reg_mutex);
 	priv->source_port = val->value.i;
-	priv->chip->set_mirror_regs(priv);
+	ar8xxx_set_mirror_regs(priv);
 	mutex_unlock(&priv->reg_mutex);
 
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_get_mirror_source_port(struct switch_dev *dev,
 				 const struct switch_attr *attr,
 				 struct switch_val *val)
@@ -1200,7 +2281,7 @@ ar8xxx_sw_get_mirror_source_port(struct switch_dev *dev,
 	return 0;
 }
 
-int
+static int
 ar8xxx_sw_set_port_reset_mib(struct switch_dev *dev,
 			     const struct switch_attr *attr,
 			     struct switch_val *val)
@@ -1230,7 +2311,7 @@ unlock:
 	return ret;
 }
 
-int
+static int
 ar8xxx_sw_get_port_mib(struct switch_dev *dev,
 		       const struct switch_attr *attr,
 		       struct switch_val *val)
@@ -1278,79 +2359,7 @@ unlock:
 	return ret;
 }
 
-int
-ar8xxx_sw_get_arl_table(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val)
-{
-	struct ar8xxx_priv *priv = swdev_to_ar8xxx(dev);
-	struct mii_bus *bus = priv->mii_bus;
-	const struct ar8xxx_chip *chip = priv->chip;
-	char *buf = priv->arl_buf;
-	int i, j, k, len = 0;
-	struct arl_entry *a, *a1;
-	u32 status;
-
-	if (!chip->get_arl_entry)
-		return -EOPNOTSUPP;
-
-	mutex_lock(&priv->reg_mutex);
-	mutex_lock(&bus->mdio_lock);
-
-	chip->get_arl_entry(priv, NULL, NULL, AR8XXX_ARL_INITIALIZE);
-
-	for(i = 0; i < AR8XXX_NUM_ARL_RECORDS; ++i) {
-		a = &priv->arl_table[i];
-		duplicate:
-		chip->get_arl_entry(priv, a, &status, AR8XXX_ARL_GET_NEXT);
-
-		if (!status)
-			break;
-
-		/* avoid duplicates
-		 * ARL table can include multiple valid entries
-		 * per MAC, just with differing status codes
-		 */
-		for (j = 0; j < i; ++j) {
-			a1 = &priv->arl_table[j];
-			if (a->port == a1->port && !memcmp(a->mac, a1->mac, sizeof(a->mac)))
-				goto duplicate;
-		}
-	}
-
-	mutex_unlock(&bus->mdio_lock);
-
-	len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
-                        "address resolution table\n");
-
-	if (i == AR8XXX_NUM_ARL_RECORDS)
-		len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
-				"Too many entries found, displaying the first %d only!\n",
-				AR8XXX_NUM_ARL_RECORDS);
-
-	for (j = 0; j < priv->dev.ports; ++j) {
-		for (k = 0; k < i; ++k) {
-			a = &priv->arl_table[k];
-			if (a->port != j)
-				continue;
-			len += snprintf(buf + len, sizeof(priv->arl_buf) - len,
-					"Port %d: MAC %02x:%02x:%02x:%02x:%02x:%02x\n",
-					j,
-					a->mac[5], a->mac[4], a->mac[3],
-					a->mac[2], a->mac[1], a->mac[0]);
-		}
-	}
-
-	val->value.s = buf;
-	val->len = len;
-
-	mutex_unlock(&priv->reg_mutex);
-
-	return 0;
-}
-
-
-static const struct switch_attr ar8xxx_sw_attr_globals[] = {
+static struct switch_attr ar8xxx_sw_attr_globals[] = {
 	{
 		.type = SWITCH_TYPE_INT,
 		.name = "enable_vlan",
@@ -1397,16 +2406,58 @@ static const struct switch_attr ar8xxx_sw_attr_globals[] = {
 		.get = ar8xxx_sw_get_mirror_source_port,
 		.max = AR8216_NUM_PORTS - 1
  	},
+};
+
+static struct switch_attr ar8327_sw_attr_globals[] = {
 	{
-		.type = SWITCH_TYPE_STRING,
-		.name = "arl_table",
-		.description = "Get ARL table",
-		.set = NULL,
-		.get = ar8xxx_sw_get_arl_table,
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_vlan",
+		.description = "Enable VLAN mode",
+		.set = ar8xxx_sw_set_vlan,
+		.get = ar8xxx_sw_get_vlan,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_NOVAL,
+		.name = "reset_mibs",
+		.description = "Reset all MIB counters",
+		.set = ar8xxx_sw_set_reset_mibs,
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_rx",
+		.description = "Enable mirroring of RX packets",
+		.set = ar8xxx_sw_set_mirror_rx_enable,
+		.get = ar8xxx_sw_get_mirror_rx_enable,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "enable_mirror_tx",
+		.description = "Enable mirroring of TX packets",
+		.set = ar8xxx_sw_set_mirror_tx_enable,
+		.get = ar8xxx_sw_get_mirror_tx_enable,
+		.max = 1
+	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_monitor_port",
+		.description = "Mirror monitor port",
+		.set = ar8xxx_sw_set_mirror_monitor_port,
+		.get = ar8xxx_sw_get_mirror_monitor_port,
+		.max = AR8327_NUM_PORTS - 1
 	},
+	{
+		.type = SWITCH_TYPE_INT,
+		.name = "mirror_source_port",
+		.description = "Mirror source port",
+		.set = ar8xxx_sw_set_mirror_source_port,
+		.get = ar8xxx_sw_get_mirror_source_port,
+		.max = AR8327_NUM_PORTS - 1
+ 	},
 };
 
-const struct switch_attr ar8xxx_sw_attr_port[2] = {
+static struct switch_attr ar8xxx_sw_attr_port[] = {
 	{
 		.type = SWITCH_TYPE_NOVAL,
 		.name = "reset_mib",
@@ -1422,7 +2473,7 @@ const struct switch_attr ar8xxx_sw_attr_port[2] = {
 	},
 };
 
-const struct switch_attr ar8xxx_sw_attr_vlan[1] = {
+static struct switch_attr ar8xxx_sw_attr_vlan[] = {
 	{
 		.type = SWITCH_TYPE_INT,
 		.name = "vid",
@@ -1455,85 +2506,26 @@ static const struct switch_dev_ops ar8xxx_sw_ops = {
 	.get_port_link = ar8xxx_sw_get_port_link,
 };
 
-static const struct ar8xxx_chip ar8216_chip = {
-	.caps = AR8XXX_CAP_MIB_COUNTERS,
-
-	.reg_port_stats_start = 0x19000,
-	.reg_port_stats_length = 0xa0,
-
-	.name = "Atheros AR8216",
-	.ports = AR8216_NUM_PORTS,
-	.vlans = AR8216_NUM_VLANS,
-	.swops = &ar8xxx_sw_ops,
-
-	.hw_init = ar8216_hw_init,
-	.init_globals = ar8216_init_globals,
-	.init_port = ar8216_init_port,
-	.setup_port = ar8216_setup_port,
-	.read_port_status = ar8216_read_port_status,
-	.atu_flush = ar8216_atu_flush,
-	.vtu_flush = ar8216_vtu_flush,
-	.vtu_load_vlan = ar8216_vtu_load_vlan,
-	.set_mirror_regs = ar8216_set_mirror_regs,
-	.sw_hw_apply = ar8xxx_sw_hw_apply,
-
-	.num_mibs = ARRAY_SIZE(ar8216_mibs),
-	.mib_decs = ar8216_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
-};
-
-static const struct ar8xxx_chip ar8236_chip = {
-	.caps = AR8XXX_CAP_MIB_COUNTERS,
-
-	.reg_port_stats_start = 0x20000,
-	.reg_port_stats_length = 0x100,
-
-	.name = "Atheros AR8236",
-	.ports = AR8216_NUM_PORTS,
-	.vlans = AR8216_NUM_VLANS,
-	.swops = &ar8xxx_sw_ops,
-
-	.hw_init = ar8216_hw_init,
-	.init_globals = ar8236_init_globals,
-	.init_port = ar8216_init_port,
-	.setup_port = ar8236_setup_port,
-	.read_port_status = ar8216_read_port_status,
-	.atu_flush = ar8216_atu_flush,
-	.vtu_flush = ar8216_vtu_flush,
-	.vtu_load_vlan = ar8216_vtu_load_vlan,
-	.set_mirror_regs = ar8216_set_mirror_regs,
-	.sw_hw_apply = ar8xxx_sw_hw_apply,
-
-	.num_mibs = ARRAY_SIZE(ar8236_mibs),
-	.mib_decs = ar8236_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
-};
-
-static const struct ar8xxx_chip ar8316_chip = {
-	.caps = AR8XXX_CAP_GIGE | AR8XXX_CAP_MIB_COUNTERS,
-
-	.reg_port_stats_start = 0x20000,
-	.reg_port_stats_length = 0x100,
-
-	.name = "Atheros AR8316",
-	.ports = AR8216_NUM_PORTS,
-	.vlans = AR8X16_MAX_VLANS,
-	.swops = &ar8xxx_sw_ops,
-
-	.hw_init = ar8316_hw_init,
-	.init_globals = ar8316_init_globals,
-	.init_port = ar8216_init_port,
-	.setup_port = ar8216_setup_port,
-	.read_port_status = ar8216_read_port_status,
-	.atu_flush = ar8216_atu_flush,
-	.vtu_flush = ar8216_vtu_flush,
-	.vtu_load_vlan = ar8216_vtu_load_vlan,
-	.set_mirror_regs = ar8216_set_mirror_regs,
-	.sw_hw_apply = ar8xxx_sw_hw_apply,
-
-	.num_mibs = ARRAY_SIZE(ar8236_mibs),
-	.mib_decs = ar8236_mibs,
-	.mib_func = AR8216_REG_MIB_FUNC
+static const struct switch_dev_ops ar8327_sw_ops = {
+	.attr_global = {
+		.attr = ar8327_sw_attr_globals,
+		.n_attr = ARRAY_SIZE(ar8327_sw_attr_globals),
+	},
+	.attr_port = {
+		.attr = ar8xxx_sw_attr_port,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_port),
+	},
+	.attr_vlan = {
+		.attr = ar8xxx_sw_attr_vlan,
+		.n_attr = ARRAY_SIZE(ar8xxx_sw_attr_vlan),
+	},
+	.get_port_pvid = ar8xxx_sw_get_pvid,
+	.set_port_pvid = ar8xxx_sw_set_pvid,
+	.get_vlan_ports = ar8327_sw_get_ports,
+	.set_vlan_ports = ar8327_sw_set_ports,
+	.apply_config = ar8xxx_sw_hw_apply,
+	.reset_switch = ar8xxx_sw_reset_switch,
+	.get_port_link = ar8xxx_sw_get_port_link,
 };
 
 static int
@@ -1543,7 +2535,7 @@ ar8xxx_id_chip(struct ar8xxx_priv *priv)
 	u16 id;
 	int i;
 
-	val = ar8xxx_read(priv, AR8216_REG_CTRL);
+	val = priv->read(priv, AR8216_REG_CTRL);
 	if (val == ~0)
 		return -ENODEV;
 
@@ -1551,7 +2543,7 @@ ar8xxx_id_chip(struct ar8xxx_priv *priv)
 	for (i = 0; i < AR8X16_PROBE_RETRIES; i++) {
 		u16 t;
 
-		val = ar8xxx_read(priv, AR8216_REG_CTRL);
+		val = priv->read(priv, AR8216_REG_CTRL);
 		if (val == ~0)
 			return -ENODEV;
 
@@ -1574,10 +2566,12 @@ ar8xxx_id_chip(struct ar8xxx_priv *priv)
 		priv->chip = &ar8316_chip;
 		break;
 	case AR8XXX_VER_AR8327:
+		priv->mii_lo_first = true;
 		priv->chip = &ar8327_chip;
 		break;
 	case AR8XXX_VER_AR8337:
-		priv->chip = &ar8337_chip;
+		priv->mii_lo_first = true;
+		priv->chip = &ar8327_chip;
 		break;
 	default:
 		pr_err("ar8216: Unknown Atheros device [ver=%d, rev=%d]\n",
@@ -1676,15 +2670,29 @@ ar8xxx_free(struct ar8xxx_priv *priv)
 	if (priv->chip && priv->chip->cleanup)
 		priv->chip->cleanup(priv);
 
-	kfree(priv->chip_data);
 	kfree(priv->mib_stats);
 	kfree(priv);
 }
 
+static struct ar8xxx_priv *
+ar8xxx_create_mii(struct mii_bus *bus)
+{
+	struct ar8xxx_priv *priv;
+
+	priv = ar8xxx_create();
+	if (priv) {
+		priv->mii_bus = bus;
+		priv->read = ar8xxx_mii_read;
+		priv->write = ar8xxx_mii_write;
+		priv->rmw = ar8xxx_mii_rmw;
+	}
+
+	return priv;
+}
+
 static int
 ar8xxx_probe_switch(struct ar8xxx_priv *priv)
 {
-	const struct ar8xxx_chip *chip;
 	struct switch_dev *swdev;
 	int ret;
 
@@ -1692,14 +2700,33 @@ ar8xxx_probe_switch(struct ar8xxx_priv *priv)
 	if (ret)
 		return ret;
 
-	chip = priv->chip;
-
 	swdev = &priv->dev;
 	swdev->cpu_port = AR8216_PORT_CPU;
-	swdev->name = chip->name;
-	swdev->vlans = chip->vlans;
-	swdev->ports = chip->ports;
-	swdev->ops = chip->swops;
+	swdev->ops = &ar8xxx_sw_ops;
+
+	if (chip_is_ar8316(priv)) {
+		swdev->name = "Atheros AR8316";
+		swdev->vlans = AR8X16_MAX_VLANS;
+		swdev->ports = AR8216_NUM_PORTS;
+	} else if (chip_is_ar8236(priv)) {
+		swdev->name = "Atheros AR8236";
+		swdev->vlans = AR8216_NUM_VLANS;
+		swdev->ports = AR8216_NUM_PORTS;
+	} else if (chip_is_ar8327(priv)) {
+		swdev->name = "Atheros AR8327";
+		swdev->vlans = AR8X16_MAX_VLANS;
+		swdev->ports = AR8327_NUM_PORTS;
+		swdev->ops = &ar8327_sw_ops;
+	} else if (chip_is_ar8337(priv)) {
+		swdev->name = "Atheros AR8337";
+		swdev->vlans = AR8X16_MAX_VLANS;
+		swdev->ports = AR8327_NUM_PORTS;
+		swdev->ops = &ar8327_sw_ops;
+	} else {
+		swdev->name = "Atheros AR8216";
+		swdev->vlans = AR8216_NUM_VLANS;
+		swdev->ports = AR8216_NUM_PORTS;
+	}
 
 	ret = ar8xxx_mib_init(priv);
 	if (ret)
@@ -1740,8 +2767,8 @@ ar8xxx_phy_config_init(struct phy_device *phydev)
 	if (WARN_ON(!priv))
 		return -ENODEV;
 
-	if (priv->chip->config_at_probe)
-		return ar8xxx_phy_check_aneg(phydev);
+	if (chip_is_ar8327(priv) || chip_is_ar8337(priv))
+		return 0;
 
 	priv->phy = phydev;
 
@@ -1773,46 +2800,12 @@ ar8xxx_phy_config_init(struct phy_device *phydev)
 	return 0;
 }
 
-static bool
-ar8xxx_check_link_states(struct ar8xxx_priv *priv)
-{
-	bool link_new, changed = false;
-	u32 status;
-	int i;
-
-	mutex_lock(&priv->reg_mutex);
-
-	for (i = 0; i < priv->dev.ports; i++) {
-		status = priv->chip->read_port_status(priv, i);
-		link_new = !!(status & AR8216_PORT_STATUS_LINK_UP);
-		if (link_new == priv->link_up[i])
-			continue;
-
-		priv->link_up[i] = link_new;
-		changed = true;
-		dev_info(&priv->phy->dev, "Port %d is %s\n",
-			 i, link_new ? "up" : "down");
-	}
-
-	if (changed)
-		priv->chip->atu_flush(priv);
-
-	mutex_unlock(&priv->reg_mutex);
-
-	return changed;
-}
-
 static int
 ar8xxx_phy_read_status(struct phy_device *phydev)
 {
 	struct ar8xxx_priv *priv = phydev->priv;
 	struct switch_port_link link;
-
-	/* check for link changes and flush ATU
-	 * if a change was detected
-	 */
-	if (phydev->state == PHY_CHANGELINK)
-		ar8xxx_check_link_states(priv);
+	int ret;
 
 	if (phydev->addr != 0)
 		return genphy_read_status(phydev);
@@ -1837,11 +2830,16 @@ ar8xxx_phy_read_status(struct phy_device *phydev)
 	}
 	phydev->duplex = link.duplex ? DUPLEX_FULL : DUPLEX_HALF;
 
+	/* flush the address translation unit */
+	mutex_lock(&priv->reg_mutex);
+	ret = priv->chip->atu_flush(priv);
+	mutex_unlock(&priv->reg_mutex);
+
 	phydev->state = PHY_RUNNING;
 	netif_carrier_on(phydev->attached_dev);
 	phydev->adjust_link(phydev->attached_dev);
 
-	return 0;
+	return ret;
 }
 
 static int
@@ -1913,14 +2911,12 @@ ar8xxx_phy_probe(struct phy_device *phydev)
 		if (priv->mii_bus == phydev->bus)
 			goto found;
 
-	priv = ar8xxx_create();
+	priv = ar8xxx_create_mii(phydev->bus);
 	if (priv == NULL) {
 		ret = -ENOMEM;
 		goto unlock;
 	}
 
-	priv->mii_bus = phydev->bus;
-
 	ret = ar8xxx_probe_switch(priv);
 	if (ret)
 		goto free_priv;
@@ -1947,7 +2943,7 @@ found:
 			phydev->advertising = ADVERTISED_100baseT_Full;
 		}
 
-		if (priv->chip->config_at_probe) {
+		if (chip_is_ar8327(priv) || chip_is_ar8337(priv)) {
 			priv->phy = phydev;
 
 			ret = ar8xxx_start(priv);
@@ -2017,15 +3013,6 @@ ar8xxx_phy_remove(struct phy_device *phydev)
 	ar8xxx_free(priv);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
-static int
-ar8xxx_phy_soft_reset(struct phy_device *phydev)
-{
-	/* we don't need an extra reset */
-	return 0;
-}
-#endif
-
 static struct phy_driver ar8xxx_phy_driver = {
 	.phy_id		= 0x004d0000,
 	.name		= "Atheros AR8216/AR8236/AR8316",
@@ -2037,9 +3024,6 @@ static struct phy_driver ar8xxx_phy_driver = {
 	.config_init	= ar8xxx_phy_config_init,
 	.config_aneg	= ar8xxx_phy_config_aneg,
 	.read_status	= ar8xxx_phy_read_status,
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,14,0)
-	.soft_reset	= ar8xxx_phy_soft_reset,
-#endif
 	.driver		= { .owner = THIS_MODULE },
 };
 
